# -*- coding: utf-8 -*-
"""
PyQt5 + PyQtGraph ê¸°ë°˜ 4ì±„ë„ ì‹¤ì‹œê°„ í”Œë¡œí„° (Binary Frame + CSV í˜¸í™˜)
- ê³ ì£¼íŒŒìˆ˜ ì‚¬ì¸íŒŒ ê°œì„  ë²„ì „
- ìŠ¤ìºí„° â†’ ë¼ì¸ ëª¨ë“œë¡œ ë³€ê²½
- ì ì‘í˜• í¬ì¸íŠ¸ ìˆ˜ ì¡°ì •
- ì•ˆí‹°ì•¨ë¦¬ì–´ì‹± ê°œì„ 
- [ìˆ˜ì •] ë°ì´í„° ë²„í¼ ê¸¸ì´ ì œí•œ í•´ì œ (ì´ì „ ë°ì´í„° í™•ì¸ ê¸°ëŠ¥)
- [ìˆ˜ì •] ê³ ì •ëœ í‘œì‹œì°½ ë° ìë™/ìˆ˜ë™ ìŠ¤í¬ë¡¤ ê¸°ëŠ¥ ì¶”ê°€
"""

import sys
import os
import csv
import struct
import threading
from threading import Lock
from collections import deque
from datetime import datetime

import serial
from serial.tools import list_ports

import numpy as np
import pyqtgraph as pg
from PyQt5 import QtWidgets, QtCore

# ===== ì„¤ì • =====
PORT = "COM3"
BAUDRATE = 1000000
UPDATE_INTERVAL_MS = 16   # (ìˆ˜ì •) ë¶€ë“œëŸ¬ìš´ ìŠ¤í¬ë¡¤ì„ ìœ„í•´ ì•½ê°„ ì¡°ì • (8 -> 16)
RECONNECT_INTERVAL_MS = 1000
Y_MIN, Y_MAX = 0, 4095
VISIBLE_SAMPLES = 5000     # (ì¶”ê°€) í™”ë©´ì— ê³ ì •ì ìœ¼ë¡œ í‘œì‹œí•  ìƒ˜í”Œ ìˆ˜
CHANNEL_COLORS_DARK = ['r', 'g', 'c', 'y']
CHANNEL_COLORS_LIGHT = ['r', 'g', 'b', 'm']

SAMPLES_PER_PACKET = 4
TARGET_TOTAL_SPS = 20000
PRINT_TO_CONSOLE = False

# ===== Binary Frame ì •ì˜ =====
FRAME_MAGIC = 0xA5C3
FRAME_HDR_FMT = "<HHHBB"
FRAME_HDR_SIZE = struct.calcsize(FRAME_HDR_FMT)
FLAG_ASCII_PAYLOAD = 0x01
FLAG_PACKED12      = 0x02

# ===== CSV í˜¸í™˜ ì—¬ë¶€ ìë™ ê°ì§€ =====
PREFER_BINARY = True


# ----- 12-bit PACKED ì–¸íŒ¨í‚¹ ìœ í‹¸ë¦¬í‹° -----
def unpack_packed12_to_i16(payload_bytes: memoryview) -> np.ndarray:
    b = np.frombuffer(payload_bytes, dtype=np.uint8)
    if b.size // 3 == 0:
        return np.empty(0, dtype=np.int16)
    if b.size % 3 != 0:
        b = b[: (b.size // 3) * 3]

    t = b.reshape(-1, 3)
    x = (t[:, 0].astype(np.uint16) | ((t[:, 1] & 0x0F).astype(np.uint16) << 8))
    y = ((t[:, 1] >> 4).astype(np.uint16) | (t[:, 2].astype(np.uint16) << 4))

    out = np.empty(x.size + y.size, dtype=np.int16)
    out[0::2] = x.astype(np.int16)
    out[1::2] = y.astype(np.int16)
    return out


class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Live ADC Data (4CH) - Scrolling View Enabled")

        # ìƒíƒœ ë³€ìˆ˜
        self.data_queues = [deque() for _ in range(4)] # maxlen ì œê±°
        self.time_queues = [deque() for _ in range(4)] # maxlen ì œê±°
        self.channel_visible = [True, True, True, True]
        self.logging_enabled = False
        self.streaming_enabled = False
        self.csv_file = None
        self.csv_writer = None
        self.csv_flush_timer = None
        self.last_csv_filename = None
        self.ser = None
        self.reader_thread = None
        self.reader_stop = threading.Event()
        self.merged = False
        self.dark_mode = True
        self.use_timestamp_xaxis = True
        self.auto_pan_enabled = True # (ì¶”ê°€) ìë™ ìŠ¤í¬ë¡¤ ìƒíƒœ í”Œë˜ê·¸

        # í†µê³„/ê°ì‹œ (ëˆ„ì )
        self.total_packets = 0
        self.lost_packets = 0
        self.malformed_lines = 0
        self.gap_count = 0
        self.last_seq = None
        self.last_time = None
        self.dt_history = deque(maxlen=200)

        # ë ˆì´íŠ¸ ê³„ì‚°(ìŠ¤ë ˆë“œ-ì„¸ì´í”„)
        self.pkts_since_last = 0
        self.frames_since_last = 0
        self.rate_lock = Lock()
        self.prev_stats_time = QtCore.QTime.currentTime()

        # ì´ˆë‹¹ í†µê³„ë¥¼ ìœ„í•œ "ìµœê·¼ 1ì´ˆ ì¦ê°€ë¶„" ì¹´ìš´í„°
        self.loss_since_last = 0
        self.malformed_since_last = 0
        self.gaps_since_last = 0

        # ë™ì  samples-per-packet
        self.last_spp = SAMPLES_PER_PACKET
        self.last_rx_time = QtCore.QTime.currentTime()
        self.logging_start_time = None
        self.sample_row_index = 0

        # ========== UI ==========
        central = QtWidgets.QWidget()
        self.setCentralWidget(central)
        vbox = QtWidgets.QVBoxLayout(central)
        ctrl = QtWidgets.QHBoxLayout()

        ctrl.addWidget(QtWidgets.QLabel("Port"))
        self.port_combo = QtWidgets.QComboBox()
        self.refresh_ports()
        ctrl.addWidget(self.port_combo)

        self.btn_refresh = QtWidgets.QPushButton("Refresh")
        self.btn_refresh.setToolTip("í¬íŠ¸ ëª©ë¡ ê°±ì‹  ë° ìë™ ì˜¤í”ˆ")
        self.btn_refresh.clicked.connect(self.on_refresh_clicked)
        ctrl.addWidget(self.btn_refresh)

        ctrl.addWidget(QtWidgets.QLabel("Pulse"))
        self.pulse_edit = QtWidgets.QLineEdit(); self.pulse_edit.setFixedWidth(70); ctrl.addWidget(self.pulse_edit)
        ctrl.addWidget(QtWidgets.QLabel("Period"))
        self.period_edit = QtWidgets.QLineEdit(); self.period_edit.setFixedWidth(70); ctrl.addWidget(self.period_edit)
        ctrl.addWidget(QtWidgets.QLabel("Duty"))
        self.duty_edit = QtWidgets.QLineEdit(); self.duty_edit.setFixedWidth(70); ctrl.addWidget(self.duty_edit)

        self.btn_stim = QtWidgets.QPushButton("Stim"); self.btn_stim.clicked.connect(self.send_stimulus); ctrl.addWidget(self.btn_stim)
        ctrl.addStretch()

        self.btn_start = QtWidgets.QPushButton("Start"); self.btn_start.clicked.connect(self.start_logging); ctrl.addWidget(self.btn_start)
        self.btn_stop  = QtWidgets.QPushButton("Stop");  self.btn_stop.clicked.connect(self.stop_logging);  ctrl.addWidget(self.btn_stop)

        self.btn_merge_split = QtWidgets.QPushButton("Merge"); self.btn_merge_split.clicked.connect(self.toggle_merge_split); ctrl.addWidget(self.btn_merge_split)
        self.btn_reset = QtWidgets.QPushButton("Reset View"); self.btn_reset.clicked.connect(self.reset_view); ctrl.addWidget(self.btn_reset)
        
        self.btn_theme = QtWidgets.QPushButton("Light Mode"); self.btn_theme.clicked.connect(self.toggle_theme); ctrl.addWidget(self.btn_theme)

        self.cb_ch = []
        for i in range(4):
            cb = QtWidgets.QCheckBox(f"CH{i+1}")
            cb.setChecked(True)
            cb.stateChanged.connect(lambda state, idx=i: self.toggle_channel(idx, state))
            self.cb_ch.append(cb); ctrl.addWidget(cb)

        self.cb_timestamp = QtWidgets.QCheckBox("Time(Î¼s) X-axis")
        self.cb_timestamp.setChecked(True)
        self.cb_timestamp.stateChanged.connect(self.toggle_timestamp_mode)
        ctrl.addWidget(self.cb_timestamp)

        self.btn_open = QtWidgets.QPushButton("Open CSV"); self.btn_open.clicked.connect(self.open_csv); ctrl.addWidget(self.btn_open)
        vbox.addLayout(ctrl)

        self.graphics = pg.GraphicsLayoutWidget(); vbox.addWidget(self.graphics)
        self.plots, self.curves = [], [] # (ìˆ˜ì •) plots ë¦¬ìŠ¤íŠ¸ë¥¼ í´ë˜ìŠ¤ ë©¤ë²„ë¡œ ì´ˆê¸°í™”
        self.create_split_plots()

        self.status = self.statusBar(); self.status.showMessage("Ready (Scrolling View Enabled)")

        self.timer = QtCore.QTimer(self); self.timer.timeout.connect(self.update_plot); self.timer.start(UPDATE_INTERVAL_MS)
        self.stats_timer = QtCore.QTimer(self); self.stats_timer.timeout.connect(self.update_statusbar_stats); self.stats_timer.start(1000)

        self.reconnect_timer = QtCore.QTimer(self)
        self.reconnect_timer.timeout.connect(self.auto_reconnect_tick)
        self.reconnect_timer.start(RECONNECT_INTERVAL_MS)

        self.try_open_serial()
        self.start_reader_thread()

        self.destroyed.connect(self.cleanup)
        self.resize(1600, 1200)

    # (ì¶”ê°€) ì‚¬ìš©ìê°€ ê·¸ë˜í”„ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ì¡°ì‘í•˜ë©´ ìë™ ìŠ¤í¬ë¡¤ì„ ë„ëŠ” í•¨ìˆ˜
    def on_range_changed(self):
        self.auto_pan_enabled = False

    # ----- í¬íŠ¸ (ì´í•˜ ë™ì¼) -----
    def refresh_ports(self):
        self.port_combo.clear()
        ports = [p.device for p in list_ports.comports()]
        if ports:
            if PORT in ports:
                ports.remove(PORT); ports.insert(0, PORT)
            self.port_combo.addItems(ports)
        else:
            self.port_combo.addItem("No Ports")

    def on_refresh_clicked(self):
        self.refresh_ports()
        if self.ser is None and not self.streaming_enabled and not self.logging_enabled:
            self.try_open_serial()

    def try_open_serial(self):
        if self.ser:
            try: self.ser.close()
            except Exception: pass
            self.ser = None

        candidates = []
        sel = self.port_combo.currentText() if self.port_combo.count() > 0 else None
        if sel and sel != "No Ports":
            candidates.append(sel)

        for p in list_ports.comports():
            desc = (p.description or "").lower()
            if any(keyword in desc for keyword in ["jlink", "j-link", "nordic", "nrf", "uart", "serial"]):
                if p.device not in candidates:
                    candidates.append(p.device)

        if not candidates:
            self.status.showMessage("No serial ports available")
            return

        def open_one(port_name: str):
            try:
                import time; time.sleep(0.1)
                ser = serial.Serial(port=port_name, baudrate=BAUDRATE, timeout=0.05, write_timeout=0.1)
                time.sleep(0.2)
                try:
                    ser.setDTR(True); ser.setRTS(True)
                    ser.reset_input_buffer(); ser.reset_output_buffer()
                except Exception: pass
                return ser
            except Exception: return None

        for port in candidates:
            ser = open_one(port)
            if not ser: continue
            ok = False
            try:
                ser.write(b"on\n"); QtCore.QThread.msleep(200)
                if ser.in_waiting: ok = True
            except Exception as e: print(f"Port {port} validation failed: {e}")

            if ok:
                try:
                    ser.write(b"off\n"); QtCore.QThread.msleep(50)
                    ser.reset_input_buffer(); ser.reset_output_buffer()
                except Exception: pass
                self.ser = ser
                idx = self.port_combo.findText(port)
                if idx >= 0: self.port_combo.setCurrentIndex(idx)
                self.status.showMessage(f"Serial opened: {port} @ {BAUDRATE}")
                self.last_rx_time = QtCore.QTime.currentTime()
                return
            else:
                try: ser.close()
                except Exception: pass
        self.status.showMessage("Serial open failed: no responding J-Link CDC port")

    def auto_reconnect_tick(self):
        if self.streaming_enabled or self.logging_enabled: return
        if self.ser is None:
            self.try_open_serial(); return
        now = QtCore.QTime.currentTime()
        elapsed = self.last_rx_time.msecsTo(now)
        if elapsed < 0: elapsed = 0
        if elapsed > 2500:
            try: self.ser.close()
            except Exception: pass
            self.ser = None
            self.try_open_serial()

    def start_reader_thread(self):
        self.reader_stop.clear()
        self.reader_thread = threading.Thread(target=self.reader_loop, daemon=True)
        self.reader_thread.start()

    def reader_loop(self):
        buf = bytearray()
        while not self.reader_stop.is_set():
            if self.ser is None or not self.ser.is_open:
                QtCore.QThread.msleep(200); continue
            try:
                chunk = self.ser.read(4096)
                if chunk:
                    self.last_rx_time = QtCore.QTime.currentTime()
                    buf += chunk
                    consumed = 0
                    if PREFER_BINARY:
                        consumed = self.try_parse_frames(buf)
                    if consumed == 0:
                        consumed = self.try_parse_csv_lines(buf)
                    
                    if consumed > 0:
                        del buf[:consumed]
                    elif len(buf) > 8192:
                        drop = self.resync_to_magic(buf)
                        if drop > 0: del buf[:drop]
            except Exception: pass

    def try_parse_frames(self, buf: bytearray) -> int:
        i, consumed_total = 0, 0
        while len(buf) - i >= FRAME_HDR_SIZE:
            magic = buf[i] | (buf[i+1] << 8)
            if magic != FRAME_MAGIC: i += 1; continue
            try: (magic_le, seq, payload_len, ch_mask, flags) = struct.unpack_from(FRAME_HDR_FMT, buf, i)
            except struct.error: break
            frame_len = FRAME_HDR_SIZE + payload_len
            if len(buf) - i < frame_len: break

            payload = memoryview(buf)[i+FRAME_HDR_SIZE : i+FRAME_HDR_SIZE+payload_len]
            if self.last_seq is not None:
                missed = (seq - ((self.last_seq + 1) & 0xFFFF)) & 0xFFFF
                if missed != 0:
                    with self.rate_lock: self.lost_packets += missed; self.loss_since_last += missed
            self.last_seq = seq; self.total_packets += 1
            with self.rate_lock: self.frames_since_last += 1

            try:
                if flags & FLAG_ASCII_PAYLOAD:
                    line = bytes(payload).decode(errors="ignore").strip()
                    self.handle_ascii_line(line)
                else:
                    arr1d = unpack_packed12_to_i16(payload) if flags & FLAG_PACKED12 else np.frombuffer(payload, dtype='<i2')
                    ch_list = [idx for idx in range(4) if (ch_mask >> idx) & 0x1] or list(range(4))
                    n_ch = len(ch_list)
                    blk = (arr1d.size // n_ch) * n_ch
                    if blk == 0: continue
                    arr = arr1d[:blk].reshape(-1, n_ch)
                    self.last_spp = arr1d.size
                    self.handle_block(None, arr, n_ch, ch_list)
            except Exception:
                with self.rate_lock: self.malformed_lines += 1; self.malformed_since_last += 1
            i += frame_len; consumed_total = i
        return consumed_total

    def try_parse_csv_lines(self, buf: bytearray) -> int:
        try:
            data = bytes(buf); nl_pos = data.find(b'\n')
            if nl_pos < 0: return 0
            line = data[:nl_pos+1].decode(errors="ignore").strip()
        except Exception: return 0
        if '*' in line: line = line.split('*', 1)[0].strip()
        if "," not in line: return nl_pos + 1
        parts = [p.strip() for p in line.split(",")]
        try:
            if len(parts) == 5: seq = int(parts[0]); values = [int(x) for x in parts[1:]]
            elif len(parts) == 4: seq = None; values = [int(x) for x in parts]
            else: raise ValueError()
            arr = np.array(values, dtype=np.int16).reshape(1, 4)
            self.handle_block(seq, arr, 4, [0, 1, 2, 3])
            self.last_spp = 4; self.total_packets += 1
            with self.rate_lock: self.frames_since_last += 1
        except ValueError:
            with self.rate_lock: self.malformed_lines += 1; self.malformed_since_last += 1
        return nl_pos + 1

    def resync_to_magic(self, buf: bytearray) -> int:
        for idx in range(max(0, len(buf) - 2048)):
            if idx + 1 < len(buf):
                m = buf[idx] | (buf[idx+1] << 8)
                if m == FRAME_MAGIC: return idx
        return len(buf) // 2

    def handle_block(self, seq, arr_i16: np.ndarray, n_ch: int, ch_list):
        if arr_i16.size == 0: return
        arr4 = arr_i16
        if len(ch_list) != 4:
            full = np.zeros((arr_i16.shape[0], 4), dtype=np.int16)
            for k, ch in enumerate(ch_list): full[:, ch] = arr_i16[:, k]
            arr4 = full
        
        if self.streaming_enabled:
            num_rows = arr4.shape[0]
            if num_rows == 0: return # (ì¶”ê°€) 0-row ë°©ì§€
            
            current_time = QtCore.QTime.currentTime()
            # (ìˆ˜ì •) ì´ ê°’ì€ ì´ì œ 'ë¸”ë¡ì˜ ë§ˆì§€ë§‰ ìƒ˜í”Œ' íƒ€ì„ìŠ¤íƒ¬í”„ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤.
            last_sample_elapsed_us = (self.logging_start_time.msecsTo(current_time) * 1000) if self.logging_start_time else 0
            
            # (ìˆ˜ì •) ê°œë³„ ìƒ˜í”Œ íƒ€ì„ìŠ¤íƒ¬í”„ ìƒì„±
            sps_per_ch = TARGET_TOTAL_SPS / 4.0 # 4ì±„ë„ ê¸°ì¤€
            
            if sps_per_ch > 0:
                time_per_sample_us = 1_000_000.0 / sps_per_ch
                
                # (ìˆ˜ì •) ë¸”ë¡ì˜ ì²« ë²ˆì§¸ ìƒ˜í”Œ ì‹œê°„ì„ ì—­ì‚°í•©ë‹ˆë‹¤.
                # (last_sample_elapsed_usê°€ ë§ˆì§€ë§‰ ìƒ˜í”Œì˜ ì‹œê°„ì´ë¯€ë¡œ)
                first_sample_time_us = last_sample_elapsed_us - ((num_rows - 1) * time_per_sample_us)
                
                # (ìˆ˜ì •) ì²« ì‹œê°„ë¶€í„° time_per_sample_us ê°„ê²©ìœ¼ë¡œ num_rowsê°œì˜ íƒ€ì„ìŠ¤íƒ¬í”„ ë°°ì—´ ìƒì„±
                time_stamps = np.arange(num_rows, dtype=np.float64) * time_per_sample_us + first_sample_time_us
            else:
                # SPSê°€ 0ì´ê±°ë‚˜ ì•Œ ìˆ˜ ì—†ëŠ” ê²½ìš°, ê¸°ì¡´ ë™ì‘(ë¸”ë¡ íƒ€ì„) ìœ ì§€
                time_stamps = np.full(num_rows, last_sample_elapsed_us, dtype=np.float64)

            for i in range(4):
                self.data_queues[i].extend(arr4[:, i])
                # (ìˆ˜ì •) [elapsed_us] * num_rows ëŒ€ì‹  ìƒì„±ëœ time_stamps ë°°ì—´ì„ ì‚¬ìš©
                self.time_queues[i].extend(time_stamps) 
            
            if self.logging_enabled and self.csv_writer:
                # (ìˆ˜ì •) CSV ë¡œê¹…ë„ ê°œë³„ íƒ€ì„ìŠ¤íƒ¬í”„ ì‚¬ìš©
                seq_col = np.full((num_rows, 1), seq if seq is not None else "", dtype=object)
                # (ìˆ˜ì •) time_stamps ë°°ì—´ì„ ì„¸ë¡œ ì—´ë¡œ ë³€í™˜
                time_col = time_stamps.reshape(-1, 1).astype(object) 
                rows = np.hstack([seq_col, arr4.astype(object), time_col]).tolist()
                self.csv_writer.writerows(rows)
                self.sample_row_index += num_rows
        
        now = QtCore.QTime.currentTime()
        if self.last_time is not None:
            dt_ms = self.last_time.msecsTo(now)
            if dt_ms >= 0:
                self.dt_history.append(dt_ms)
                if len(self.dt_history) >= 20:
                    median_dt = sorted(self.dt_history)[len(self.dt_history)//2]
                    threshold = max(10, 3 * median_dt)
                    if dt_ms > threshold:
                        with self.rate_lock: self.gap_count += 1; self.gaps_since_last += 1
        self.last_time = now

    def handle_ascii_line(self, line: str):
        if PRINT_TO_CONSOLE and line: print(f"[ASCII] {line}", flush=True)

    def update_statusbar_stats(self):
        now = QtCore.QTime.currentTime()
        dt_s = max(0.001, self.prev_stats_time.msecsTo(now) / 1000.0)
        with self.rate_lock:
            delta_frames, self.frames_since_last = self.frames_since_last, 0
            delta_loss, self.loss_since_last = self.loss_since_last, 0
            delta_malformed, self.malformed_since_last = self.malformed_since_last, 0
            delta_gaps, self.gaps_since_last = self.gaps_since_last, 0

        rx_fps = delta_frames / dt_s
        total_sps = rx_fps * max(1, self.last_spp)
        per_ch_sps = total_sps / 4.0
        achieve = (total_sps / TARGET_TOTAL_SPS * 100.0) if TARGET_TOTAL_SPS > 0 else 0.0
        target_k = int(TARGET_TOTAL_SPS / 1000)
        mode = "BINâ†’CSV" if PREFER_BINARY else "CSV only"
        self.status.showMessage(
            f"mode={mode} | pkt={self.total_packets}  |  "
            f"rxâ‰ˆ{rx_fps:,.1f} fps  spsâ‰ˆ{total_sps:,.1f}  per-châ‰ˆ{per_ch_sps:,.1f}  |  "
            f"loss/sâ‰ˆ{delta_loss/dt_s:.2f}  malformed/sâ‰ˆ{delta_malformed/dt_s:.2f}  gaps/sâ‰ˆ{delta_gaps/dt_s:.2f}  |  "
            f"target({target_k}k)â‰ˆ{achieve:,.1f}%"
        )
        self.prev_stats_time = now

    def start_logging(self):
        if self.ser is None: self.try_open_serial()
        if self.ser is None: QtWidgets.QMessageBox.warning(self, "Serial", "Serial open failed."); return
        if not self.logging_enabled:
            self.total_packets, self.lost_packets, self.malformed_lines, self.gap_count = 0, 0, 0, 0
            self.last_seq, self.last_time = None, None
            self.dt_history.clear(); self.sample_row_index = 0
            
            self.data_queues = [deque() for _ in range(4)]
            self.time_queues = [deque() for _ in range(4)]
            with self.rate_lock: self.frames_since_last, self.loss_since_last, self.malformed_since_last, self.gaps_since_last = 0, 0, 0, 0
            
            try: self.ser.reset_input_buffer(); self.ser.reset_output_buffer()
            except Exception: pass
            
            self.logging_start_time = QtCore.QTime.currentTime()
            filename = f"adc_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
            self.last_csv_filename = filename
            try:
                self.csv_file = open(filename, mode="w", newline="")
                self.csv_writer = csv.writer(self.csv_file)
                self.csv_writer.writerow(["SEQ", "CH1", "CH2", "CH3", "CH4", "Time(us)"])
            except Exception as e: QtWidgets.QMessageBox.warning(self, "CSV", f"Failed to open CSV: {e}"); return

            self.csv_flush_timer = QtCore.QTimer(self)
            self.csv_flush_timer.timeout.connect(lambda: (self.csv_file and self.csv_file.flush()))
            self.csv_flush_timer.start(1000)
            
            self.logging_enabled = True; self.streaming_enabled = True
            try: self.ser.write(b"on\n")
            except Exception: pass
            self.status.showMessage(f"ğŸŸ¢ Logging started â†’ {filename}")

    def stop_logging(self):
        if self.logging_enabled:
            try:
                if self.ser: self.ser.write(b"off\n")
            except Exception: pass
            self.logging_enabled = False; self.streaming_enabled = False
            try:
                if self.csv_flush_timer: self.csv_flush_timer.stop(); self.csv_flush_timer = None
                if self.csv_file: self.csv_file.flush(); self.csv_file.close()
            finally:
                self.csv_file, self.csv_writer, self.logging_start_time = None, None, None
            self.status.showMessage("ğŸ›‘ Logging stopped. CSV file closed.")

    def send_stimulus(self):
        pulses, period, duty = self.pulse_edit.text().strip(), self.period_edit.text().strip(), self.duty_edit.text().strip()
        if not (pulses.isdigit() and period.isdigit() and duty.isdigit()):
            QtWidgets.QMessageBox.warning(self, "Stim", "Invalid input. Use integers."); return
        cmd = f"{pulses},{period},{duty}\n".encode()
        try:
            if self.ser is None: self.try_open_serial()
            if self.ser: self.ser.write(cmd); self.status.showMessage(f"ğŸ“¤ Sent stimulus: {pulses},{period},{duty}")
        except Exception as e: QtWidgets.QMessageBox.warning(self, "Serial", f"Write failed: {e}")

    def toggle_channel(self, idx, state): self.channel_visible[idx] = (state == QtCore.Qt.Checked)
    
    def toggle_timestamp_mode(self, state):
        self.use_timestamp_xaxis = (state == QtCore.Qt.Checked)
        if self.merged: self.merged = False; self.toggle_merge_split()
        else: self.create_split_plots()
    
    def toggle_theme(self):
        self.dark_mode = not self.dark_mode
        bg_color, fg_color = ('k', 'w') if self.dark_mode else ('w', 'k')
        pg.setConfigOption('background', bg_color); pg.setConfigOption('foreground', fg_color)
        self.btn_theme.setText("Light Mode" if self.dark_mode else "Dark Mode")
        old_widget, self.graphics = self.graphics, pg.GraphicsLayoutWidget()
        self.centralWidget().layout().replaceWidget(old_widget, self.graphics)
        old_widget.deleteLater()
        if self.merged: self.merged = False; self.toggle_merge_split()
        else: self.create_split_plots()

    def open_csv(self):
        if self.last_csv_filename and os.path.exists(self.last_csv_filename):
            try: os.startfile(self.last_csv_filename)
            except AttributeError: import subprocess; opener = "open" if sys.platform == "darwin" else "xdg-open"; subprocess.call([opener, self.last_csv_filename])
        else: QtWidgets.QMessageBox.information(self, "CSV", "No CSV file to open.")

    # ----- ê·¸ë˜í”„ -----
    def create_split_plots(self):
        self.graphics.clear()
        self.plots, self.curves = [], []
        colors = CHANNEL_COLORS_DARK if self.dark_mode else CHANNEL_COLORS_LIGHT
        for i in range(4):
            p = self.graphics.addPlot(row=i, col=0)
            p.showGrid(x=True, y=True)
            p.setLabel("left", f"CH{i+1}", units="V")
            p.setLabel("bottom", "Time", units="Î¼s") if self.use_timestamp_xaxis else p.setLabel("bottom", "Sample Index")
            p.getAxis("left").setScale(1e-3)
            p.setYRange(Y_MIN, Y_MAX)
            p.setMouseEnabled(x=True, y=True)
            p.sigRangeChanged.connect(self.on_range_changed) # (ì¶”ê°€) ì‹œê·¸ë„ ì—°ê²°
            self.plots.append(p)
            curve = p.plot([], [], pen=None, symbol='o', symbolSize=5, symbolBrush=colors[i], symbolPen=None)
            self.curves.append(curve)

    def toggle_merge_split(self):
        self.graphics.clear()
        colors = CHANNEL_COLORS_DARK if self.dark_mode else CHANNEL_COLORS_LIGHT
        self.plots, self.curves = [], []
        
        if not self.merged:
            p = self.graphics.addPlot(row=0, col=0)
            p.showGrid(x=True, y=True)
            p.setLabel("left", "Voltage", units="V")
            p.setLabel("bottom", "Time", units="Î¼s") if self.use_timestamp_xaxis else p.setLabel("bottom", "Sample Index")
            p.getAxis("left").setScale(1e-3)
            p.setYRange(Y_MIN, Y_MAX)
            p.setMouseEnabled(x=True, y=True)
            p.sigRangeChanged.connect(self.on_range_changed) # (ì¶”ê°€) ì‹œê·¸ë„ ì—°ê²°
            self.plots.append(p)
            for i in range(4):
                curve = p.plot([], [], pen=None, symbol='o', symbolSize=5, symbolBrush=colors[i], symbolPen=None, name=f"CH{i+1}")
                self.curves.append(curve)
            self.merged = True; self.btn_merge_split.setText("Split")
        else:
            self.create_split_plots()
            self.merged = False; self.btn_merge_split.setText("Merge")

    # (ìˆ˜ì •) Reset View ë²„íŠ¼ ë¡œì§ ë³€ê²½
    def reset_view(self):
        self.auto_pan_enabled = True # ìë™ ìŠ¤í¬ë¡¤ í™œì„±í™”
        for p in self.plots:
             p.setYRange(Y_MIN, Y_MAX) # Yì¶•ì€ ê³ ì •ëœ ë²”ìœ„ë¡œ ë¦¬ì…‹
        self.update_plot() # update_plotì„ í˜¸ì¶œí•˜ì—¬ Xì¶• ë²”ìœ„ë¥¼ ìµœì‹ ìœ¼ë¡œ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
        self.status.showMessage("ğŸ”„ View reset. Auto-scrolling enabled.")

    # (ìˆ˜ì •) Plot ì—…ë°ì´íŠ¸ ë¡œì§ ì „ì²´ ë³€ê²½
    def update_plot(self):
        # 1. ëª¨ë“  ì»¤ë¸Œì˜ ë°ì´í„°ë¥¼ ì—…ë°ì´íŠ¸ (ì „ì²´ ë°ì´í„°)
        for i in range(len(self.curves)):
            if self.channel_visible[i]:
                dq = self.data_queues[i]
                if dq:
                    y = np.array(dq)
                    if self.use_timestamp_xaxis:
                        x = np.array(self.time_queues[i], dtype=np.float64)
                    else:
                        x = np.arange(y.size, dtype=np.int32)
                    self.curves[i].setData(x=x, y=y, pen=None)
                else:
                    self.curves[i].clear()
            else:
                self.curves[i].clear()
        
        # 2. ìë™ ìŠ¤í¬ë¡¤ì´ í™œì„±í™”ëœ ê²½ìš°ì—ë§Œ Xì¶• í‘œì‹œ ë²”ìœ„ë¥¼ ì¡°ì •
        if self.auto_pan_enabled and self.data_queues[0]:
            num_samples = len(self.data_queues[0])
            if num_samples > 1:
                start_x, last_x = 0, 0
                if self.use_timestamp_xaxis:
                    tq = self.time_queues[0]
                    last_x = tq[-1]
                    start_idx = max(0, num_samples - VISIBLE_SAMPLES)
                    start_x = tq[start_idx]
                else: # Index mode
                    last_x = num_samples - 1
                    start_x = max(0, last_x - VISIBLE_SAMPLES)

                # 3. ëª¨ë“  í”Œë¡¯ì˜ Xì¶• ë²”ìœ„ë¥¼ ë™ê¸°í™” (í”¼ë“œë°± ë°©ì§€ ì²˜ë¦¬ í¬í•¨)
                for plot in self.plots:
                    try:
                        plot.sigRangeChanged.disconnect(self.on_range_changed)
                        plot.setXRange(start_x, last_x, padding=0)
                        plot.sigRangeChanged.connect(self.on_range_changed)
                    except (TypeError, RuntimeError):
                        pass # ì´ë¯¸ ì—°ê²°ì´ ëŠì–´ì¡Œì„ ê²½ìš° ë“± ì˜ˆì™¸ ì²˜ë¦¬

    # ----- ì¢…ë£Œ -----
    def cleanup(self):
        self.reader_stop.set()
        if self.reader_thread and self.reader_thread.is_alive():
            try: self.reader_thread.join(timeout=1.0)
            except Exception: pass
        if self.csv_flush_timer:
            try: self.csv_flush_timer.stop()
            except Exception: pass
        if self.csv_file:
            try: self.csv_file.flush(); self.csv_file.close()
            except Exception: pass
        if self.ser:
            try: self.ser.close()
            except Exception: pass

def main():
    app = QtWidgets.QApplication(sys.argv)
    pg.setConfigOptions(antialias=True, useOpenGL=True, enableExperimental=True)
    pg.setConfigOption('background', 'k')
    pg.setConfigOption('foreground', 'w')
    win = MainWindow(); win.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
