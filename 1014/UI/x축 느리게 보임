# -*- coding: utf-8 -*-
"""
PyQt5 + PyQtGraph ê¸°ë°˜ 4ì±„ë„ ì‹¤ì‹œê°„ í”Œë¡œí„° (Binary Frame + CSV í˜¸í™˜)
- ê³ ì£¼íŒŒìˆ˜ ì‚¬ì¸íŒŒ ê°œì„  ë²„ì „
- ìŠ¤ìºí„° â†’ ë¼ì¸ ëª¨ë“œë¡œ ë³€ê²½
- ì ì‘í˜• í¬ì¸íŠ¸ ìˆ˜ ì¡°ì •
- ì•ˆí‹°ì•¨ë¦¬ì–´ì‹± ê°œì„ 
"""

import sys
import os
import csv
import struct
import threading
from threading import Lock
from collections import deque
from datetime import datetime

import serial
from serial.tools import list_ports

import numpy as np
import pyqtgraph as pg
from PyQt5 import QtWidgets, QtCore

# ===== ì„¤ì • =====
PORT = "COM3"              # ì´ˆê¸° ì„ íƒìš© ê¸°ë³¸ í¬íŠ¸(ì—†ì–´ë„ OK)
BAUDRATE = 1000000         # ê¶Œì¥: 1_000_000 ì´ìƒ (ë³´ë“œ/ë“œë¼ì´ë²„ ê°€ëŠ¥ ì‹œ)
MAX_POINTS = 15000         # â˜… ì´ˆëŒ€í˜• ë²„í¼: 10000 â†’ 15000 (ê·¸ë˜í”„ ëŠê¹€ ë°©ì§€)
UPDATE_INTERVAL_MS = 8     # â˜… ê· í˜•ì¡íŒ ì—…ë°ì´íŠ¸: 5 â†’ 8 (SPSì™€ ì•ˆì •ì„± ê· í˜•)
RECONNECT_INTERVAL_MS = 1000  # ìë™ ì¬ì—°ê²° ì²´í¬ ì£¼ê¸°
Y_MIN, Y_MAX = 0, 4095     # 12-bit ì›ë³¸ ë²”ìœ„
CHANNEL_COLORS_DARK = ['r', 'g', 'c', 'y']      # ë‹¤í¬ëª¨ë“œìš© ë°ì€ ìƒ‰ìƒ
CHANNEL_COLORS_LIGHT = ['r', 'g', 'b', 'm']     # ë¼ì´íŠ¸ëª¨ë“œìš© ì§„í•œ ìƒ‰ìƒ

SAMPLES_PER_PACKET = 4       # ì´ˆê¸° í†µê³„ìš© ê¸°ë³¸ê°’(ë™ì ìœ¼ë¡œ self.last_sppë¡œ ëŒ€ì²´ë¨)
TARGET_TOTAL_SPS = 20000     # ì´í•© ëª©í‘œ SPS (5k/ch Ã— 4ch) - ë©”ì¸ ì½”ë“œì™€ ì¼ì¹˜
PRINT_TO_CONSOLE = False

# ===== Binary Frame ì •ì˜ =====
FRAME_MAGIC = 0xA5C3
FRAME_HDR_FMT = "<HHHBB"     # magic, seq, payload_len, ch_mask, flags (little-endian)
FRAME_HDR_SIZE = struct.calcsize(FRAME_HDR_FMT)
FLAG_ASCII_PAYLOAD = 0x01
FLAG_PACKED12      = 0x02     # payloadê°€ 12-bit packed(2ìƒ˜í”Œâ†’3ë°”ì´íŠ¸)

# ===== CSV í˜¸í™˜ ì—¬ë¶€ ìë™ ê°ì§€ =====
PREFER_BINARY = True         # Trueë©´ ë¨¼ì € ë°”ì´ë„ˆë¦¬ ì‹œë„, ì•ˆ ë§ìœ¼ë©´ CSV ì¤„ë„ ë³‘í–‰ íŒŒì‹±


# ----- 12-bit PACKED ì–¸íŒ¨í‚¹ ìœ í‹¸ë¦¬í‹° -----
def unpack_packed12_to_i16(payload_bytes: memoryview) -> np.ndarray:
    """
    3ë°”ì´íŠ¸(2ìƒ˜í”Œ, 12-bitÃ—2)ë¥¼ int16 ë‘ ê°œë¡œ ë³µì›í•´ ì „ì²´ payloadë¥¼ int16 1ì°¨ì› ë°°ì—´ë¡œ ë°˜í™˜.
    """
    b = np.frombuffer(payload_bytes, dtype=np.uint8)
    if b.size // 3 == 0:
        return np.empty(0, dtype=np.int16)
    if b.size % 3 != 0:
        b = b[: (b.size // 3) * 3]  # ê¼¬ë¦¬ ì˜ë¼ ì •ë ¬

    t = b.reshape(-1, 3)
    # 12-bit little-endian packing (x: low 8 + low4, y: high4 + next 8)
    x = (t[:, 0].astype(np.uint16) | ((t[:, 1] & 0x0F).astype(np.uint16) << 8))
    y = ((t[:, 1] >> 4).astype(np.uint16) | (t[:, 2].astype(np.uint16) << 4))

    out = np.empty(x.size + y.size, dtype=np.int16)
    out[0::2] = x.astype(np.int16)
    out[1::2] = y.astype(np.int16)
    return out


class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Live ADC Data (4CH) - High Frequency Optimized")

        # ìƒíƒœ ë³€ìˆ˜
        self.data_queues = [deque([0]*MAX_POINTS, maxlen=MAX_POINTS) for _ in range(4)]
        self.time_queues = [deque([0.0]*MAX_POINTS, maxlen=MAX_POINTS) for _ in range(4)]  # íƒ€ì„ìŠ¤íƒ¬í”„ ë²„í¼
        self.channel_visible = [True, True, True, True]
        self.logging_enabled = False
        self.streaming_enabled = False
        self.csv_file = None
        self.csv_writer = None
        self.csv_flush_timer = None
        self.last_csv_filename = None
        self.ser = None
        self.reader_thread = None
        self.reader_stop = threading.Event()
        self.merged = False
        self.dark_mode = True  # ê¸°ë³¸ì€ ë‹¤í¬ëª¨ë“œ
        self.use_timestamp_xaxis = False  # False=ìƒ˜í”Œ ì¸ë±ìŠ¤, True=íƒ€ì„ìŠ¤íƒ¬í”„

        # í†µê³„/ê°ì‹œ (ëˆ„ì )
        self.total_packets = 0          # ìˆ˜ì‹ í•œ í”„ë ˆì„ ìˆ˜
        self.lost_packets = 0
        self.malformed_lines = 0
        self.gap_count = 0
        self.last_seq = None
        self.last_time = None
        self.dt_history = deque(maxlen=200)

        # ë ˆì´íŠ¸ ê³„ì‚°(ìŠ¤ë ˆë“œ-ì„¸ì´í”„)
        self.pkts_since_last = 0
        self.frames_since_last = 0
        self.rate_lock = Lock()
        self.prev_stats_time = QtCore.QTime.currentTime()

        # ì´ˆë‹¹ í†µê³„ë¥¼ ìœ„í•œ "ìµœê·¼ 1ì´ˆ ì¦ê°€ë¶„" ì¹´ìš´í„°
        self.loss_since_last = 0
        self.malformed_since_last = 0
        self.gaps_since_last = 0

        # ë™ì  samples-per-packet (í”„ë ˆì„ ì „ì²´ int16 ê°œìˆ˜)
        self.last_spp = SAMPLES_PER_PACKET

        # ë§ˆì§€ë§‰ ìˆ˜ì‹  ì‹œê° (ìë™ ì¬ì—°ê²° íŒë‹¨ìš©)
        self.last_rx_time = QtCore.QTime.currentTime()
        
        # CSV íƒ€ì„ìŠ¤íƒ¬í”„ìš© ë³€ìˆ˜
        self.logging_start_time = None
        self.sample_row_index = 0  # CSVì— ê¸°ë¡ëœ í–‰(row) ìˆ˜

        # ========== UI ==========
        central = QtWidgets.QWidget()
        self.setCentralWidget(central)
        vbox = QtWidgets.QVBoxLayout(central)

        ctrl = QtWidgets.QHBoxLayout()

        # Port ì„ íƒ
        ctrl.addWidget(QtWidgets.QLabel("Port"))
        self.port_combo = QtWidgets.QComboBox()
        self.refresh_ports()
        ctrl.addWidget(self.port_combo)

        # Refresh ë²„íŠ¼
        self.btn_refresh = QtWidgets.QPushButton("Refresh")
        self.btn_refresh.setToolTip("í¬íŠ¸ ëª©ë¡ ê°±ì‹  ë° ìë™ ì˜¤í”ˆ")
        self.btn_refresh.clicked.connect(self.on_refresh_clicked)
        ctrl.addWidget(self.btn_refresh)

        # Stim íŒŒë¼ë¯¸í„°
        ctrl.addWidget(QtWidgets.QLabel("Pulse"))
        self.pulse_edit = QtWidgets.QLineEdit(); self.pulse_edit.setFixedWidth(70); ctrl.addWidget(self.pulse_edit)
        ctrl.addWidget(QtWidgets.QLabel("Period"))
        self.period_edit = QtWidgets.QLineEdit(); self.period_edit.setFixedWidth(70); ctrl.addWidget(self.period_edit)
        ctrl.addWidget(QtWidgets.QLabel("Duty"))
        self.duty_edit = QtWidgets.QLineEdit(); self.duty_edit.setFixedWidth(70); ctrl.addWidget(self.duty_edit)

        self.btn_stim = QtWidgets.QPushButton("Stim"); self.btn_stim.clicked.connect(self.send_stimulus); ctrl.addWidget(self.btn_stim)
        ctrl.addStretch()

        # Start/Stop
        self.btn_start = QtWidgets.QPushButton("Start"); self.btn_start.clicked.connect(self.start_logging); ctrl.addWidget(self.btn_start)
        self.btn_stop  = QtWidgets.QPushButton("Stop");  self.btn_stop.clicked.connect(self.stop_logging);  ctrl.addWidget(self.btn_stop)

        # Merge/Split + Reset
        self.btn_merge_split = QtWidgets.QPushButton("Merge"); self.btn_merge_split.clicked.connect(self.toggle_merge_split); ctrl.addWidget(self.btn_merge_split)
        self.btn_reset = QtWidgets.QPushButton("Reset View"); self.btn_reset.clicked.connect(self.reset_view); ctrl.addWidget(self.btn_reset)
        
        # Dark/Light Mode
        self.btn_theme = QtWidgets.QPushButton("Light Mode"); self.btn_theme.clicked.connect(self.toggle_theme); ctrl.addWidget(self.btn_theme)

        # ì±„ë„ í† ê¸€
        self.cb_ch = []
        for i in range(4):
            cb = QtWidgets.QCheckBox(f"CH{i+1}")
            cb.setChecked(True)
            cb.stateChanged.connect(lambda state, idx=i: self.toggle_channel(idx, state))
            self.cb_ch.append(cb); ctrl.addWidget(cb)

        # Xì¶• íƒ€ì„ìŠ¤íƒ¬í”„ ëª¨ë“œ
        self.cb_timestamp = QtWidgets.QCheckBox("Time(Î¼s) X-axis")
        self.cb_timestamp.setChecked(False)
        self.cb_timestamp.stateChanged.connect(self.toggle_timestamp_mode)
        ctrl.addWidget(self.cb_timestamp)

        # Open CSV
        self.btn_open = QtWidgets.QPushButton("Open CSV"); self.btn_open.clicked.connect(self.open_csv); ctrl.addWidget(self.btn_open)
        vbox.addLayout(ctrl)

        # ê·¸ë˜í”„
        self.graphics = pg.GraphicsLayoutWidget(); vbox.addWidget(self.graphics)
        self.create_split_plots()

        # ìƒíƒœë°”
        self.status = self.statusBar(); self.status.showMessage("Ready (High Frequency Optimized)")

        # íƒ€ì´ë¨¸ë“¤
        self.timer = QtCore.QTimer(self); self.timer.timeout.connect(self.update_plot); self.timer.start(UPDATE_INTERVAL_MS)
        self.stats_timer = QtCore.QTimer(self); self.stats_timer.timeout.connect(self.update_statusbar_stats); self.stats_timer.start(1000)

        # ìë™ ì¬ì—°ê²° íƒ€ì´ë¨¸
        self.reconnect_timer = QtCore.QTimer(self)
        self.reconnect_timer.timeout.connect(self.auto_reconnect_tick)
        self.reconnect_timer.start(RECONNECT_INTERVAL_MS)

        # ì‹œë¦¬ì–¼ & ë¦¬ë” ìŠ¤ë ˆë“œ
        self.try_open_serial()
        self.start_reader_thread()

        self.destroyed.connect(self.cleanup)
        self.resize(1600, 1200)  # â˜… ì°½ í¬ê¸° ëŒ€í­ ì¦ê°€ (500Hz ì‹ í˜¸ í‘œì‹œìš©)

    # ----- í¬íŠ¸ -----
    def refresh_ports(self):
        self.port_combo.clear()
        ports = [p.device for p in list_ports.comports()]
        if ports:
            if PORT in ports:
                ports.remove(PORT); ports.insert(0, PORT)
            self.port_combo.addItems(ports)
        else:
            self.port_combo.addItem("No Ports")

    def on_refresh_clicked(self):
        self.refresh_ports()
        # ì—°ê²°ì´ ì—†ì„ ë•Œë§Œ ìë™ ì˜¤í”ˆ ì‹œë„ (ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ëŠì§€ ì•ŠìŒ)
        if self.ser is None and not self.streaming_enabled and not self.logging_enabled:
            self.try_open_serial()

    def try_open_serial(self):
        """
        J-Link CDC í¬íŠ¸ë¥¼ ìë™ íƒì§€ + DTR/RTS í™œì„±í™” + ìê°€ê²€ì¦.
        """
        # 0) ê¸°ì¡´ ì—°ê²° ë‹«ê¸°
        if self.ser:
            try:
                self.ser.close()
            except Exception:
                pass
            self.ser = None

        # 1) í›„ë³´ ìˆ˜ì§‘ (ë“œë¡­ë‹¤ìš´ ì„ íƒ ìš°ì„ )
        candidates = []
        sel = self.port_combo.currentText() if self.port_combo.count() > 0 else None
        if sel and sel != "No Ports":
            candidates.append(sel)

        # J-Link CDC í›„ë³´ ì¶”ê°€ (ë” ë„“ì€ ë²”ìœ„ë¡œ ê°ì§€)
        for p in list_ports.comports():
            desc = (p.description or "").lower()
            if any(keyword in desc for keyword in ["jlink", "j-link", "nordic", "nrf", "uart", "serial"]):
                if p.device not in candidates:
                    candidates.append(p.device)

        if not candidates:
            self.status.showMessage("No serial ports available")
            return

        def open_one(port_name: str):
            try:
                # ì‹œë¦¬ì–¼ í¬íŠ¸ ì—°ê²° ì „ ì ì‹œ ëŒ€ê¸°
                import time
                time.sleep(0.1)
                
                ser = serial.Serial(
                    port=port_name,
                    baudrate=BAUDRATE,
                    timeout=0.05,  # â˜… SPS í–¥ìƒì„ ìœ„í•´ íƒ€ì„ì•„ì›ƒ ë‹¨ì¶•
                    write_timeout=0.1,  # â˜… SPS í–¥ìƒì„ ìœ„í•´ ì“°ê¸° íƒ€ì„ì•„ì›ƒ ë‹¨ì¶•
                    bytesize=serial.EIGHTBITS,
                    parity=serial.PARITY_NONE,
                    stopbits=serial.STOPBITS_ONE,
                    xonxoff=False,
                    rtscts=False,
                    dsrdtr=False,
                )
                
                # ì—°ê²° í›„ ì ì‹œ ëŒ€ê¸°
                time.sleep(0.2)
                try:
                    ser.setDTR(True)
                    ser.setRTS(True)
                    ser.reset_input_buffer()
                    ser.reset_output_buffer()
                except Exception:
                    pass
                return ser
            except Exception:
                return None

        # 2) í›„ë³´ë“¤ì„ ìˆœì„œëŒ€ë¡œ ì—´ì–´ë³´ë©° ìê°€ê²€ì¦
        for port in candidates:
            try:
                ser = open_one(port)
                if not ser:
                    continue
                ok = False
                try:
                    # ê²€ì¦: on -> 200ms ëŒ€ê¸° -> ë°”ì´íŠ¸ ìœ ì… í™•ì¸
                    ser.write(b"on\n")
                    QtCore.QThread.msleep(200)
                    if ser.in_waiting:
                        ok = True
                except Exception as e:
                    print(f"Port {port} validation failed: {e}")
                    ok = False
            except Exception as e:
                print(f"Port {port} open failed: {e}")
                continue

            if ok:
                # ì„±ê³µ: ì¦‰ì‹œ offë¡œ ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì§€, ë²„í¼ í´ë¦¬ì–´ â†’ ì•± Startì™€ ë™ê¸°í™”
                try:
                    ser.write(b"off\n")
                    QtCore.QThread.msleep(50)
                    ser.reset_input_buffer()
                    ser.reset_output_buffer()
                except Exception:
                    pass

                self.ser = ser
                idx = self.port_combo.findText(port)
                if idx >= 0:
                    self.port_combo.setCurrentIndex(idx)
                self.status.showMessage(f"Serial opened: {port} @ {BAUDRATE}")
                self.last_rx_time = QtCore.QTime.currentTime()
                return
            else:
                try:
                    ser.close()
                except Exception:
                    pass

        # ì‹¤íŒ¨
        self.status.showMessage("Serial open failed: no responding J-Link CDC port")

    # ìë™ ì¬ì—°ê²°
    def auto_reconnect_tick(self):
        # ìŠ¤íŠ¸ë¦¬ë°/ë¡œê¹… ì¤‘ì—” ê±´ë“œë¦¬ì§€ ì•ŠìŒ
        if self.streaming_enabled or self.logging_enabled:
            return

        # í¬íŠ¸ê°€ ë¹„ì–´ ìˆìœ¼ë©´ ì‹œë„
        if self.ser is None:
            self.try_open_serial()
            return

        # ìµœê·¼ ìˆ˜ì‹ ì´ ì—†ê³ (>2.5s) í¬íŠ¸ê°€ ì£½ì€ ë“¯ í•˜ë©´ ì¬ì˜¤í”ˆ
        now = QtCore.QTime.currentTime()
        elapsed = self.last_rx_time.msecsTo(now)
        if elapsed < 0:
            elapsed = 0
        if elapsed > 2500:
            try:
                self.ser.close()
            except Exception:
                pass
            self.ser = None
            self.try_open_serial()

    def start_reader_thread(self):
        self.reader_stop.clear()
        self.reader_thread = threading.Thread(target=self.reader_loop, daemon=True)
        self.reader_thread.start()

    # ----- ìˆ˜ì‹  ë£¨í”„ (ë°”ì´ë„ˆë¦¬ ìš°ì„  + CSV ë°±ì—…) -----
    def reader_loop(self):
        buf = bytearray()
        while not self.reader_stop.is_set():
            if self.ser is None:
                QtCore.QThread.msleep(200); continue
            try:
                # ì•ˆì „í•œ ì‹œë¦¬ì–¼ ì½ê¸°
                if not self.ser.is_open:
                    QtCore.QThread.msleep(200); continue
                    
                chunk = self.ser.read(4096)
                if chunk:
                    self.last_rx_time = QtCore.QTime.currentTime()  # ìµœê·¼ ìˆ˜ì‹  ì‹œê° ê°±ì‹ 
                    buf += chunk
                    # 1) ë°”ì´ë„ˆë¦¬ í”„ë ˆì„ ì‹œë„
                    if PREFER_BINARY:
                        consumed = self.try_parse_frames(buf)
                        if consumed > 0:
                            del buf[:consumed]
                            continue
                    # 2) CSV ì¤„ íŒŒì‹± (ê°œí–‰ ê¸°ì¤€)
                    consumed = self.try_parse_csv_lines(buf)
                    if consumed > 0:
                        del buf[:consumed]
                        continue
                    # 3) ë²„í¼ ê³¼ë„ ì„±ì¥ ë°©ì§€: magic ê²€ìƒ‰ í›„ ì•ë¶€ë¶„ ë²„ë¦¼
                    if len(buf) > 8192:
                        drop = self.resync_to_magic(buf)
                        if drop > 0:
                            del buf[:drop]
            except Exception:
                pass  # ì¡ìŒ ë“± ë¬´ì‹œ

    # ----- Binary Frame íŒŒì„œ (í”„ë ˆì„ ì „ì²´ ë””ì¸í„°ë¦¬ë¸Œ) -----
    def try_parse_frames(self, buf: bytearray) -> int:
        """ê°€ëŠ¥í•œ ë§Œí¼ í”„ë ˆì„ì„ íŒŒì‹±í•˜ê³  ì†Œë¹„í•œ ë°”ì´íŠ¸ ìˆ˜ë¥¼ ë°˜í™˜"""
        i = 0
        consumed_total = 0
        while True:
            if len(buf) - i < FRAME_HDR_SIZE:
                break
            # magic ê²€ì‚¬ (LE)
            magic = buf[i] | (buf[i+1] << 8)
            if magic != FRAME_MAGIC:
                i += 1
                continue
            # í—¤ë” íŒŒì‹±
            try:
                (magic_le, seq, payload_len, ch_mask, flags) = struct.unpack_from(FRAME_HDR_FMT, buf, i)
            except struct.error:
                break
            frame_len = FRAME_HDR_SIZE + payload_len
            if len(buf) - i < frame_len:
                break  # ë” ì½ì–´ì•¼ í•¨

            payload = memoryview(buf)[i+FRAME_HDR_SIZE : i+FRAME_HDR_SIZE+payload_len]

            # í”„ë ˆì„ ë‹¨ìœ„ ë¡œìŠ¤/ì¹´ìš´íŠ¸
            if self.last_seq is not None:
                expected = (self.last_seq + 1) & 0xFFFF
                missed = (seq - expected) & 0xFFFF
                if missed != 0:
                    with self.rate_lock:
                        self.lost_packets += missed
                        self.loss_since_last += missed
                    if PRINT_TO_CONSOLE:
                        print(f"[LOSS] missed {missed} pkt(s): last={self.last_seq}, got={seq}", flush=True)
            self.last_seq = seq
            self.total_packets += 1
            with self.rate_lock:
                self.frames_since_last += 1

            # flags ì²˜ë¦¬
            if flags & FLAG_ASCII_PAYLOAD:
                try:
                    line = bytes(payload).decode(errors="ignore").strip()
                    self.handle_ascii_line(line)
                except Exception:
                    with self.rate_lock:
                        self.malformed_lines += 1
                        self.malformed_since_last += 1
            elif flags & FLAG_PACKED12:
                # 12-bit packed ì–¸íŒ¨í‚¹ ê²½ë¡œ
                try:
                    arr1d = unpack_packed12_to_i16(payload)  # int16 1D
                    # ch_mask â†’ ì‚¬ìš© ì±„ë„ ëª©ë¡
                    ch_list = [idx for idx in range(4) if (ch_mask >> idx) & 0x1]
                    if not ch_list:
                        ch_list = [0, 1, 2, 3]
                    n_ch = len(ch_list)

                    blk = (arr1d.size // n_ch) * n_ch
                    if blk != arr1d.size:
                        arr1d = arr1d[:blk]

                    samples = blk // n_ch
                    arr = arr1d.reshape(samples, n_ch)  # (samples, n_ch)

                    self.last_spp = arr1d.size  # í”„ë ˆì„ ë‚´ int16 ê°œìˆ˜
                    self.handle_block(None, arr, n_ch, ch_list)
                except Exception:
                    with self.rate_lock:
                        self.malformed_lines += 1
                        self.malformed_since_last += 1
            else:
                # ê¸°ë³¸: 16-bit LE unpack
                try:
                    cnt = payload_len // 2
                    arr = np.frombuffer(payload, dtype='<i2', count=cnt)

                    ch_list = [idx for idx in range(4) if (ch_mask >> idx) & 0x1]
                    if not ch_list:
                        ch_list = [0, 1, 2, 3]
                    n_ch = len(ch_list)

                    blk = (cnt // n_ch) * n_ch
                    if blk != cnt:
                        arr = arr[:blk]

                    samples = blk // n_ch
                    arr = arr.reshape(samples, n_ch)  # (samples, n_ch)
                    self.last_spp = cnt

                    # í”„ë ˆì„ë‹¹ 1ë²ˆë§Œ ë¸”ë¡ ë°˜ì˜
                    self.handle_block(None, arr, n_ch, ch_list)

                except Exception:
                    with self.rate_lock:
                        self.malformed_lines += 1
                        self.malformed_since_last += 1

            i += frame_len
            consumed_total = i
        return consumed_total

    # ----- CSV ì¤„ íŒŒì„œ (í•˜ìœ„í˜¸í™˜) -----
    def try_parse_csv_lines(self, buf: bytearray) -> int:
        try:
            data = bytes(buf)
            nl_pos = data.find(b'\n')
            if nl_pos < 0:
                return 0
            line = data[:nl_pos+1].decode(errors="ignore").strip()
        except Exception:
            return 0

        # ì²´í¬ì„¬ ì œê±°
        if '*' in line:
            line = line.split('*', 1)[0].strip()
        if "," not in line:
            return nl_pos + 1

        parts = [p.strip() for p in line.split(",")]
        seq = None; values = None
        try:
            if len(parts) == 5:
                seq = int(parts[0]); values = [int(x) for x in parts[1:]]
            elif len(parts) == 4:
                values = [int(x) for x in parts]
            else:
                with self.rate_lock:
                    self.malformed_lines += 1
                    self.malformed_since_last += 1
        except ValueError:
            with self.rate_lock:
                self.malformed_lines += 1
                self.malformed_since_last += 1
            return nl_pos + 1

        if values and len(values) == 4:
            # CSVë„ ë¸”ë¡ ê²½ë¡œë¡œ (1Ã—4)
            arr = np.array(values, dtype=np.int16).reshape(1, 4)
            self.handle_block(seq, arr, 4, [0, 1, 2, 3])
            self.last_spp = 4
            self.total_packets += 1
            with self.rate_lock:
                self.frames_since_last += 1

        return nl_pos + 1

    # ----- magic ì¬ë™ê¸°í™” -----
    def resync_to_magic(self, buf: bytearray) -> int:
        """ë²„í¼ì—ì„œ magic(LE)ì„ ì°¾ì•„ ê·¸ ì „ê¹Œì§€ ë²„ë¦¼"""
        for idx in range(max(0, len(buf) - 2048)):
            if idx + 1 < len(buf):
                m = buf[idx] | (buf[idx+1] << 8)
                if m == FRAME_MAGIC:
                    return idx
        # ëª» ì°¾ìœ¼ë©´ ì ˆë°˜ ë²„ë¦¼
        return len(buf) // 2

    # ----- (ì‹ ê·œ) ë¸”ë¡ ì²˜ë¦¬: ê·¸ë˜í”„/CSV í•œ ë²ˆì— -----
    def handle_block(self, seq, arr_i16: np.ndarray, n_ch: int, ch_list):
        if arr_i16.size == 0:
            return

        # ch_mask ë°˜ì˜: 4ì±„ë„ í˜•íƒœë¡œ í™•ì¥
        if len(ch_list) != 4:
            full = np.zeros((arr_i16.shape[0], 4), dtype=np.int16)
            for k, ch in enumerate(ch_list):
                full[:, ch] = arr_i16[:, k]
            arr4 = full
        else:
            arr4 = arr_i16

        # ê·¸ë˜í”„/ë²„í¼ - ìµœì í™”ëœ ì²˜ë¦¬
        if self.streaming_enabled:
            num_rows = arr4.shape[0]
            
            # ì‹œê°„ ì»¬ëŸ¼ ìƒì„± (ì‹œì‘ ì‹œê°„ìœ¼ë¡œë¶€í„°ì˜ ê²½ê³¼ ì‹œê°„, Î¼s)
            current_time = QtCore.QTime.currentTime()
            if self.logging_start_time:
                elapsed_us = self.logging_start_time.msecsTo(current_time) * 1000  # ms â†’ Î¼s
            else:
                elapsed_us = 0
            
            # â˜… ë²¡í„°í™”ëœ ì²˜ë¦¬ë¡œ ì„±ëŠ¥ í–¥ìƒ
            for i in range(4):
                self.data_queues[i].extend(arr4[:, i])
                # íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ time_queuesì— ì €ì¥ (ëª¨ë“  í–‰ì— ë™ì¼í•œ íƒ€ì„ìŠ¤íƒ¬í”„)
                self.time_queues[i].extend([elapsed_us] * num_rows)

            # CSV ë¸”ë¡ ì“°ê¸°
            if self.logging_enabled and self.csv_writer:
                # ê° í–‰ì˜ íƒ€ì„ìŠ¤íƒ¬í”„ ìƒì„± (í˜„ì¬ ì‹œê°„ ê¸°ì¤€)
                time_col = np.full((num_rows, 1), elapsed_us, dtype=object)
                
                if seq is not None:
                    seq_col = np.full((num_rows, 1), seq, dtype=object)
                else:
                    seq_col = np.full((num_rows, 1), "", dtype=object)
                
                # SEQ, CH1, CH2, CH3, CH4, Time(us) ìˆœì„œë¡œ ê²°í•©
                rows = np.hstack([seq_col, arr4.astype(object), time_col]).tolist()
                self.csv_writer.writerows(rows)
                
                self.sample_row_index += num_rows

        # ê°„ê²© ê¸°ë°˜ ê°­ ê°ì§€
        now = QtCore.QTime.currentTime()
        if self.last_time is not None:
            dt_ms = self.last_time.msecsTo(now)
            if dt_ms >= 0:
                self.dt_history.append(dt_ms)
                if len(self.dt_history) >= 20:
                    median_dt = sorted(self.dt_history)[len(self.dt_history)//2]
                    threshold = max(10, 3 * median_dt)
                    if dt_ms > threshold:
                        with self.rate_lock:
                            self.gap_count += 1
                            self.gaps_since_last += 1
                        if PRINT_TO_CONSOLE:
                            print(f"[GAP] dt={dt_ms}ms (>~{threshold}ms)", flush=True)
        self.last_time = now

    # ----- (ê¸°ì¡´) ë‹¨ì¼ ìƒ˜í”Œ ì²˜ë¦¬: í•˜ìœ„í˜¸í™˜ ê²½ë¡œì—ì„œë§Œ ì‚¬ìš© -----
    def handle_sample(self, seq, values):
        now = QtCore.QTime.currentTime()

        if PRINT_TO_CONSOLE:
            if seq is not None:
                print(f"{seq},{values[0]},{values[1]},{values[2]},{values[3]}", flush=True)
            else:
                print(f"{values[0]},{values[1]},{values[2]},{values[3]}", flush=True)

        if self.last_time is not None:
            dt_ms = self.last_time.msecsTo(now)
            if dt_ms >= 0:
                self.dt_history.append(dt_ms)
                if len(self.dt_history) >= 20:
                    median_dt = sorted(self.dt_history)[len(self.dt_history)//2]
                    threshold = max(10, 3 * median_dt)
                    if dt_ms > threshold:
                        with self.rate_lock:
                            self.gap_count += 1
                            self.gaps_since_last += 1
                        if PRINT_TO_CONSOLE:
                            print(f"[GAP] dt={dt_ms}ms (>~{threshold}ms)", flush=True)
        self.last_time = now

        if self.streaming_enabled:
            # ê²½ê³¼ ì‹œê°„ ê³„ì‚° (Î¼s ë‹¨ìœ„)
            current_time = QtCore.QTime.currentTime()
            elapsed_us = (self.logging_start_time.msecsTo(current_time) * 1000) if self.logging_start_time else 0
            
            for i in range(4):
                self.data_queues[i].append(values[i])
                self.time_queues[i].append(elapsed_us)
                
            if self.logging_enabled and self.csv_writer:
                if seq is not None: 
                    self.csv_writer.writerow([seq] + values + [elapsed_us])
                else:               
                    self.csv_writer.writerow([""] + values + [elapsed_us])
                
                self.sample_row_index += 1

    # ----- ASCII ëª…ë ¹ ì²˜ë¦¬ (flags & 0x01ì¼ ë•Œ) -----
    def handle_ascii_line(self, line: str):
        if not line:
            return
        if PRINT_TO_CONSOLE:
            print(f"[ASCII] {line}", flush=True)

    # ----- ìƒíƒœë°” -----
    def update_statusbar_stats(self):
        now = QtCore.QTime.currentTime()
        dt_s = max(0.001, self.prev_stats_time.msecsTo(now) / 1000.0)
        with self.rate_lock:
            delta_frames = self.frames_since_last
            self.frames_since_last = 0

            delta_loss = self.loss_since_last
            delta_malformed = self.malformed_since_last
            delta_gaps = self.gaps_since_last
            self.loss_since_last = 0
            self.malformed_since_last = 0
            self.gaps_since_last = 0

        rx_fps = delta_frames / dt_s

        # í”„ë ˆì„ë‹¹ ì´ int16 ê°œìˆ˜(ë™ì ) ê¸°ì¤€ìœ¼ë¡œ sps í™˜ì‚°
        total_sps = rx_fps * max(1, self.last_spp)
        per_ch_sps = total_sps / 4.0
        achieve = (total_sps / TARGET_TOTAL_SPS * 100.0) if TARGET_TOTAL_SPS > 0 else 0.0
        
        # â˜… ì‹œê°„ ìŠ¤ì¼€ì¼ìš© SPS ì €ì¥
        self.current_sps = per_ch_sps

        target_k = int(TARGET_TOTAL_SPS / 1000)
        mode = "BINâ†’CSV" if PREFER_BINARY else "CSV only"
        self.status.showMessage(
            f"mode={mode} | pkt={self.total_packets}  |  "
            f"rxâ‰ˆ{rx_fps:,.1f} fps  spsâ‰ˆ{total_sps:,.1f}  per-châ‰ˆ{per_ch_sps:,.1f}  |  "
            f"loss/sâ‰ˆ{delta_loss/dt_s:.2f}  malformed/sâ‰ˆ{delta_malformed/dt_s:.2f}  gaps/sâ‰ˆ{delta_gaps/dt_s:.2f}  |  "
            f"target({target_k}k)â‰ˆ{achieve:,.1f}%"
        )
        self.prev_stats_time = now

    # ----- ë²„íŠ¼ í•¸ë“¤ëŸ¬ -----
    def start_logging(self):
        if self.ser is None:
            self.try_open_serial()
            if self.ser is None:
                QtWidgets.QMessageBox.warning(self, "Serial", "Serial open failed.")
                return
        if not self.logging_enabled:
            # í†µê³„/ìƒíƒœ ì´ˆê¸°í™”
            self.total_packets = 0
            self.lost_packets = 0
            self.malformed_lines = 0
            self.gap_count = 0
            self.last_seq = None
            self.last_time = None
            self.dt_history.clear()
            self.sample_row_index = 0
            
            # ë²„í¼ ì´ˆê¸°í™”
            self.data_queues = [deque([], maxlen=MAX_POINTS) for _ in range(4)]
            self.time_queues = [deque([], maxlen=MAX_POINTS) for _ in range(4)]
            
            with self.rate_lock:
                self.frames_since_last = 0
                self.loss_since_last = 0
                self.malformed_since_last = 0
                self.gaps_since_last = 0

            # ë²„í¼ ì‹¹ ë¹„ìš°ê³  ì‹œì‘
            try:
                self.ser.reset_input_buffer()
                self.ser.reset_output_buffer()
            except Exception:
                pass

            # ë¡œê¹… ì‹œì‘ ì‹œê°„ ê¸°ë¡
            self.logging_start_time = QtCore.QTime.currentTime()

            filename = f"adc_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
            self.last_csv_filename = filename
            try:
                self.csv_file = open(filename, mode="w", newline="")
                self.csv_writer = csv.writer(self.csv_file)
                self.csv_writer.writerow(["SEQ", "CH1", "CH2", "CH3", "CH4", "Time(us)"])
            except Exception as e:
                QtWidgets.QMessageBox.warning(self, "CSV", f"Failed to open CSV: {e}")
                return

            # ì£¼ê¸°ì  í”ŒëŸ¬ì‹œ (I/O ë³‘ëª© ë°©ì§€ + ë°ì´í„° ë³´ì¡´)
            self.csv_flush_timer = QtCore.QTimer(self)
            self.csv_flush_timer.timeout.connect(lambda: (self.csv_file and self.csv_file.flush()))
            self.csv_flush_timer.start(1000)

            self.logging_enabled = True
            self.streaming_enabled = True
            try:
                self.ser.write(b"on\n")   # ë³´ë“œë¡œ ASCII ëª…ë ¹ ì „ì†¡(í˜„ êµ¬ì¡° ìœ ì§€)
            except Exception:
                pass

            self.status.showMessage(f"ğŸŸ¢ Logging started â†’ {filename}")

    def stop_logging(self):
        if self.logging_enabled:
            try:
                if self.ser:
                    self.ser.write(b"off\n")
            except Exception:
                pass
            
            # ë¡œê¹… í†µê³„ ê³„ì‚°
            if self.logging_start_time:
                stop_time = QtCore.QTime.currentTime()
                total_elapsed_ms = self.logging_start_time.msecsTo(stop_time)
                total_elapsed_sec = total_elapsed_ms / 1000.0
                
                if self.sample_row_index > 0:
                    avg_interval_us = (total_elapsed_ms * 1000) / self.sample_row_index
                    msg = (f"ğŸ›‘ Logging stopped. "
                           f"Duration: {total_elapsed_sec:.2f}s, "
                           f"Rows: {self.sample_row_index}, "
                           f"Avg interval: {avg_interval_us:.1f}Î¼s/row")
                    self.status.showMessage(msg)
                    if PRINT_TO_CONSOLE:
                        print(f"\n[LOGGING STATS]", flush=True)
                        print(f"  Total time: {total_elapsed_sec:.2f} seconds", flush=True)
                        print(f"  Total rows: {self.sample_row_index}", flush=True)
                        print(f"  Avg interval: {avg_interval_us:.1f} Î¼s/row", flush=True)
                        print(f"  Effective rate: {self.sample_row_index/total_elapsed_sec:.1f} rows/sec\n", flush=True)
        
        self.logging_enabled = False
        self.streaming_enabled = False
        try:
            if self.csv_flush_timer:
                self.csv_flush_timer.stop()
                self.csv_flush_timer = None
            if self.csv_file:
                self.csv_file.flush()
                self.csv_file.close()
        finally:
            self.csv_file = None
            self.csv_writer = None
            self.logging_start_time = None
            
        if not hasattr(self, 'status') or not self.logging_start_time:
            self.status.showMessage("ğŸ›‘ Logging stopped. CSV file closed.")

    def send_stimulus(self):
        pulses = self.pulse_edit.text().strip()
        period = self.period_edit.text().strip()
        duty   = self.duty_edit.text().strip()
        if not (pulses.isdigit() and period.isdigit() and duty.isdigit()):
            QtWidgets.QMessageBox.warning(self, "Stim", "Invalid input. Use integers."); return
        cmd = f"{pulses},{period},{duty}\n".encode()
        try:
            if self.ser is None: self.try_open_serial()
            if self.ser:
                self.ser.write(cmd)   # ASCII ëª…ë ¹ ì „ì†¡(í•˜ìœ„í˜¸í™˜)
                self.status.showMessage(f"ğŸ“¤ Sent stimulus: {pulses},{period},{duty}")
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Serial", f"Write failed: {e}")

    def toggle_channel(self, idx, state):
        self.channel_visible[idx] = (state == QtCore.Qt.Checked)
    
    def toggle_timestamp_mode(self, state):
        """ìƒ˜í”Œ ì¸ë±ìŠ¤ <-> íƒ€ì„ìŠ¤íƒ¬í”„ Xì¶• ëª¨ë“œ ì „í™˜"""
        self.use_timestamp_xaxis = (state == QtCore.Qt.Checked)
        # Xì¶• ë ˆì´ë¸” ì—…ë°ì´íŠ¸
        if self.merged:
            self.merged = False
            self.toggle_merge_split()
        else:
            self.create_split_plots()
    
    def toggle_theme(self):
        """ë‹¤í¬ëª¨ë“œ <-> ë¼ì´íŠ¸ëª¨ë“œ ì „í™˜"""
        self.dark_mode = not self.dark_mode
        
        if self.dark_mode:
            # ë‹¤í¬ëª¨ë“œ
            pg.setConfigOption('background', 'k')
            pg.setConfigOption('foreground', 'w')
            self.btn_theme.setText("Light Mode")
        else:
            # ë¼ì´íŠ¸ëª¨ë“œ
            pg.setConfigOption('background', 'w')
            pg.setConfigOption('foreground', 'k')
            self.btn_theme.setText("Dark Mode")
        
        # ê·¸ë˜í”„ ìœ„ì ¯ ì™„ì „íˆ ì¬ìƒì„±
        old_widget = self.graphics
        self.graphics = pg.GraphicsLayoutWidget()
        
        # ë ˆì´ì•„ì›ƒì—ì„œ ê¸°ì¡´ ìœ„ì ¯ êµì²´
        layout = self.centralWidget().layout()
        layout.replaceWidget(old_widget, self.graphics)
        old_widget.deleteLater()
        
        # ê·¸ë˜í”„ ì¬ìƒì„±
        if self.merged:
            self.merged = False  # ìƒíƒœ ë¦¬ì…‹
            self.toggle_merge_split()  # Mergeë¡œ ì „í™˜
        else:
            self.create_split_plots()

    def open_csv(self):
        if self.last_csv_filename and os.path.exists(self.last_csv_filename):
            try: os.startfile(self.last_csv_filename)
            except AttributeError:
                import subprocess; opener = "open" if sys.platform == "darwin" else "xdg-open"
                subprocess.call([opener, self.last_csv_filename])
        else:
            QtWidgets.QMessageBox.showMessage(self, "CSV", "No CSV file to open.")

    # ----- ê·¸ë˜í”„ (ê³ ì£¼íŒŒìˆ˜ ê°œì„ ) -----
    def create_split_plots(self):
        self.graphics.clear()
        self.plots, self.curves = [], []
        colors = CHANNEL_COLORS_DARK if self.dark_mode else CHANNEL_COLORS_LIGHT
        
        for i in range(4):
            p = self.graphics.addPlot(row=i, col=0)
            p.showGrid(x=True, y=True)
            p.setLabel("left", f"CH{i+1}", units="V")
            
            # Xì¶• ë ˆì´ë¸”ì„ ëª¨ë“œì— ë”°ë¼ ì„¤ì •
            if self.use_timestamp_xaxis:
                p.setLabel("bottom", "Time", units="Î¼s")
            else:
                p.setLabel("bottom", "Sample Index")
                
            p.getAxis("left").setScale(1e-3)        # mV â†’ V (í‘œì‹œìš©)
            p.setYRange(Y_MIN, Y_MAX)
            p.setMouseEnabled(x=True, y=True)
            
            # â˜… 500Hz ì‹ í˜¸ ê°œì„ : ìŠ¤ìºí„° ëª¨ë“œ ìµœì í™”
            curve = p.plot([], [],
                           pen=None,              # â˜… ë¼ì¸ ì œê±° (ìŠ¤ìºí„°ë§Œ)
                           symbol='o',            # â˜… ì›í˜• ì‹¬ë³¼
                           symbolSize=5,          # â˜… ê°€ì‹œì„± í–¥ìƒ
                           symbolBrush=colors[i],
                           symbolPen=None)
            self.plots.append(p); self.curves.append(curve)

    def toggle_merge_split(self):
        self.graphics.clear()
        colors = CHANNEL_COLORS_DARK if self.dark_mode else CHANNEL_COLORS_LIGHT
        
        if not self.merged:
            p = self.graphics.addPlot(row=0, col=0)
            p.showGrid(x=True, y=True)
            p.setLabel("left", "Voltage", units="V")
            
            # Xì¶• ë ˆì´ë¸”ì„ ëª¨ë“œì— ë”°ë¼ ì„¤ì •
            if self.use_timestamp_xaxis:
                p.setLabel("bottom", "Time", units="Î¼s")
            else:
                p.setLabel("bottom", "Sample Index")
                
            p.getAxis("left").setScale(1e-3)
            p.setYRange(Y_MIN, Y_MAX)
            p.setMouseEnabled(x=True, y=True)
            self.curves = []
            for i in range(4):
                # â˜… 500Hz ì‹ í˜¸ ê°œì„ : ìŠ¤ìºí„° ëª¨ë“œ ìµœì í™”
                self.curves.append(p.plot([], [],
                                          pen=None,              # â˜… ë¼ì¸ ì œê±° (ìŠ¤ìºí„°ë§Œ)
                                          symbol='o',            # â˜… ì›í˜• ì‹¬ë³¼
                                          symbolSize=5,          # â˜… ê°€ì‹œì„± í–¥ìƒ
                                          symbolBrush=colors[i],
                                          symbolPen=None,
                                          name=f"CH{i+1}"))
            self.merged = True; self.btn_merge_split.setText("Split")
        else:
            self.create_split_plots()
            self.merged = False; self.btn_merge_split.setText("Merge")

    def reset_view(self):
        if self.merged:
            if self.curves:
                vb = self.curves[0].getViewBox()
                vb.setXRange(0, MAX_POINTS); vb.setYRange(Y_MIN, Y_MAX)
        else:
            for c in self.curves:
                vb = c.getViewBox()
                vb.setXRange(0, MAX_POINTS); vb.setYRange(Y_MIN, Y_MAX)
        self.status.showMessage("ğŸ”„ View reset")

    def update_plot(self):
        # â˜… 500Hz ì‹ í˜¸ ê°œì„ : ìŠ¤ìºí„° ëª¨ë“œ ìµœì í™” + ìŠ¤ë§ˆíŠ¸ ë‹¤ìš´ìƒ˜í”Œë§
        for i in range(len(self.curves)):
            if self.channel_visible[i]:
                dq = self.data_queues[i]
                tq = self.time_queues[i]
                if dq:
                    y = np.fromiter(dq, dtype=np.int16, count=len(dq))
                    
                    # Xì¶• ë°ì´í„° ì„ íƒ: íƒ€ì„ìŠ¤íƒ¬í”„ ëª¨ë“œ vs ìƒ˜í”Œ ì¸ë±ìŠ¤ ëª¨ë“œ
                    if self.use_timestamp_xaxis:
                        # íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ xì¶•ìœ¼ë¡œ ì‚¬ìš©
                        x = np.fromiter(tq, dtype=np.float32, count=len(tq))
                    else:
                        # ìƒ˜í”Œ ì¸ë±ìŠ¤ë¥¼ xì¶•ìœ¼ë¡œ ì‚¬ìš©
                        x = np.arange(y.size, dtype=np.int32)
                    
                    # â˜… 20000 SPS ëŒ€ì‘: ë” ì ê·¹ì ì¸ ë‹¤ìš´ìƒ˜í”Œë§
                    if len(y) > 2000:  # 2000ê°œ ì´ìƒì¼ ë•Œ ë‹¤ìš´ìƒ˜í”Œë§
                        # 20000 SPS ëŒ€ì‘ì„ ìœ„í•œ ì ì‘í˜• ë‹¤ìš´ìƒ˜í”Œë§
                        target_points = 2000  # 20000 SPS ëŒ€ì‘
                        step = max(1, len(y) // target_points)
                        x = x[::step]
                        y = y[::step]
                    
                    # â˜… 500Hz ì‹ í˜¸ ê°œì„ : ìŠ¤ìºí„° ëª¨ë“œ ìµœì í™”
                    self.curves[i].setData(x, y, pen=None)
                else:
                    self.curves[i].setData([], [], pen=None)
            else:
                self.curves[i].setData([], [], pen=None)

    # ----- ì¢…ë£Œ -----
    def cleanup(self):
        self.reader_stop.set()
        if self.reader_thread and self.reader_thread.is_alive():
            try:
                self.reader_thread.join(timeout=1.0)
            except Exception:
                pass
        if self.csv_flush_timer:
            try: self.csv_flush_timer.stop()
            except Exception: pass
        if self.csv_file:
            try:
                self.csv_file.flush()
                self.csv_file.close()
            except Exception: pass
        if self.ser:
            try: self.ser.close()
            except Exception: pass


def main():
    app = QtWidgets.QApplication(sys.argv)
    # â˜… ê³ ì£¼íŒŒìˆ˜ ê°œì„ : ì•ˆí‹°ì•¨ë¦¬ì–´ì‹± ê°•í™”
    pg.setConfigOptions(antialias=True, useOpenGL=True, enableExperimental=True)
    # ê¸°ë³¸ ë‹¤í¬ëª¨ë“œ ì„¤ì •
    pg.setConfigOption('background', 'k')
    pg.setConfigOption('foreground', 'w')
    win = MainWindow(); win.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
