# -*- coding: utf-8 -*-
"""
PyQt5 + PyQtGraph 4Ï±ÑÎÑê Ïã§ÏãúÍ∞Ñ ÌîåÎ°úÌÑ∞ (Binary Frame + CSV Ìò∏Ìôò)
‚òÖ ÏãúÍ∞ÑÏ∂ïÏùÑ 'ÎÖºÎ¶¨Ï†Å ÏÉòÌîå ÏãúÍ∞Ñ'ÏúºÎ°ú Íµ¨ÏÑ± (ÏûÖÏàò Î∞∞Ïπò ÌÉÄÏù¥Î∞ç Î¨¥Ïãú)
"""

import sys, os, csv, struct, threading
from threading import Lock
from collections import deque
from datetime import datetime

import serial
from serial.tools import list_ports
import numpy as np
import pyqtgraph as pg
from PyQt5 import QtWidgets, QtCore

# ===== ÏÑ§Ï†ï =====
PORT = "COM3"
BAUDRATE = 1000000
MAX_POINTS = 2000
UPDATE_INTERVAL_MS = 100
RECONNECT_INTERVAL_MS = 1000
Y_MIN, Y_MAX = 0, 4095
CHANNEL_COLORS = ['r', 'g', 'b', 'y']

TARGET_TOTAL_SPS = 64000   # Ï¥ùÌï© Î™©Ìëú SPS (4Ï±ÑÎÑê Ìï©Í≥Ñ)
PRINT_TO_CONSOLE = False

# ===== Frame Ï†ïÏùò =====
FRAME_MAGIC = 0xA5C3
FRAME_HDR_FMT = "<HHHBB"   # magic, seq, payload_len, ch_mask, flags
FRAME_HDR_SIZE = struct.calcsize(FRAME_HDR_FMT)
FLAG_ASCII_PAYLOAD = 0x01
FLAG_PACKED12      = 0x02

PREFER_BINARY = True

def unpack_packed12_to_i16(payload_bytes: memoryview) -> np.ndarray:
    b = np.frombuffer(payload_bytes, dtype=np.uint8)
    if b.size // 3 == 0:
        return np.empty(0, dtype=np.int16)
    if b.size % 3 != 0:
        b = b[: (b.size // 3) * 3]
    t = b.reshape(-1, 3)
    x = (t[:, 0].astype(np.uint16) | ((t[:, 1] & 0x0F).astype(np.uint16) << 8))
    y = ((t[:, 1] >> 4).astype(np.uint16) | (t[:, 2].astype(np.uint16) << 4))
    out = np.empty(x.size + y.size, dtype=np.int16)
    out[0::2] = x.astype(np.int16)
    out[1::2] = y.astype(np.int16)
    return out

class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Live ADC Data (4CH) - Binary Frame + CSV compatible")

        # Îç∞Ïù¥ÌÑ∞/ÏãúÍ∞Ñ Î≤ÑÌçº
        self.data_queues = [deque([0]*MAX_POINTS, maxlen=MAX_POINTS) for _ in range(4)]
        self.time_queues = [deque([0.0]*MAX_POINTS, maxlen=MAX_POINTS) for _ in range(4)]

        # ‚òÖ ÎÖºÎ¶¨Ï†Å ÏãúÍ∞Ñ Ï∂ï Î≥ÄÏàò
        self.t0_ms = None                 # Î°úÍπÖ ÏãúÏûë Ïãú Î≤ΩÏãúÍ≥Ñ Í∏∞Ï§Ä(ms)
        self.global_row_idx = 0           # Î∞õÏùÄ 'Ìñâ(row)' Í∞úÏàò ÎàÑÏ†Å (Ìñâ=ÎèôÏùº ÏãúÍ∞ÅÏùò 4Ï±ÑÎÑê ÏÉòÌîå)
        self.t_step_ms = 1000.0 * (4.0 / float(TARGET_TOTAL_SPS))  # Ìñâ Í∞Ñ ÏãúÍ∞Ñ Í∞ÑÍ≤©(ms)

        self.channel_visible = [True, True, True, True]
        self.logging_enabled = False
        self.streaming_enabled = False
        self.csv_file = None
        self.csv_writer = None
        self.csv_flush_timer = None
        self.last_csv_filename = None
        self.ser = None
        self.reader_thread = None
        self.reader_stop = threading.Event()
        self.merged = False

        # ÌÜµÍ≥Ñ
        self.total_packets = 0
        self.lost_packets = 0
        self.malformed_lines = 0
        self.gap_count = 0
        self.last_seq = None
        self.prev_stats_time = QtCore.QTime.currentTime()
        self.rate_lock = Lock()
        self.frames_since_last = 0
        self.loss_since_last = 0
        self.malformed_since_last = 0
        self.gaps_since_last = 0
        self.last_rx_time = QtCore.QTime.currentTime()
        self.last_spp = 0

        # ===== UI =====
        central = QtWidgets.QWidget(); self.setCentralWidget(central)
        vbox = QtWidgets.QVBoxLayout(central)
        ctrl = QtWidgets.QHBoxLayout()

        ctrl.addWidget(QtWidgets.QLabel("Port"))
        self.port_combo = QtWidgets.QComboBox(); self.refresh_ports(); ctrl.addWidget(self.port_combo)

        self.btn_refresh = QtWidgets.QPushButton("Refresh"); self.btn_refresh.clicked.connect(self.on_refresh_clicked); ctrl.addWidget(self.btn_refresh)

        ctrl.addWidget(QtWidgets.QLabel("Pulse"));  self.pulse_edit  = QtWidgets.QLineEdit(); self.pulse_edit.setFixedWidth(70);  ctrl.addWidget(self.pulse_edit)
        ctrl.addWidget(QtWidgets.QLabel("Period")); self.period_edit = QtWidgets.QLineEdit(); self.period_edit.setFixedWidth(70); ctrl.addWidget(self.period_edit)
        ctrl.addWidget(QtWidgets.QLabel("Duty"));   self.duty_edit   = QtWidgets.QLineEdit(); self.duty_edit.setFixedWidth(70);   ctrl.addWidget(self.duty_edit)
        self.btn_stim = QtWidgets.QPushButton("Stim"); self.btn_stim.clicked.connect(self.send_stimulus); ctrl.addWidget(self.btn_stim)

        ctrl.addStretch()
        self.btn_start = QtWidgets.QPushButton("Start"); self.btn_start.clicked.connect(self.start_logging); ctrl.addWidget(self.btn_start)
        self.btn_stop  = QtWidgets.QPushButton("Stop");  self.btn_stop.clicked.connect(self.stop_logging);  ctrl.addWidget(self.btn_stop)
        self.btn_merge_split = QtWidgets.QPushButton("Merge"); self.btn_merge_split.clicked.connect(self.toggle_merge_split); ctrl.addWidget(self.btn_merge_split)
        self.btn_reset = QtWidgets.QPushButton("Reset View"); self.btn_reset.clicked.connect(self.reset_view); ctrl.addWidget(self.btn_reset)

        self.cb_ch = []
        for i in range(4):
            cb = QtWidgets.QCheckBox(f"CH{i+1}"); cb.setChecked(True)
            cb.stateChanged.connect(lambda state, idx=i: self.toggle_channel(idx, state))
            self.cb_ch.append(cb); ctrl.addWidget(cb)

        self.btn_open = QtWidgets.QPushButton("Open CSV"); self.btn_open.clicked.connect(self.open_csv); ctrl.addWidget(self.btn_open)
        vbox.addLayout(ctrl)

        self.graphics = pg.GraphicsLayoutWidget(); vbox.addWidget(self.graphics)
        self.create_split_plots()

        self.status = self.statusBar(); self.status.showMessage("Ready (BIN first, CSV fallback)")

        self.timer = QtCore.QTimer(self); self.timer.timeout.connect(self.update_plot); self.timer.start(UPDATE_INTERVAL_MS)
        self.stats_timer = QtCore.QTimer(self); self.stats_timer.timeout.connect(self.update_statusbar_stats); self.stats_timer.start(1000)

        self.reconnect_timer = QtCore.QTimer(self); self.reconnect_timer.timeout.connect(self.auto_reconnect_tick); self.reconnect_timer.start(RECONNECT_INTERVAL_MS)

        self.try_open_serial()
        self.start_reader_thread()

        self.destroyed.connect(self.cleanup)
        self.resize(1100, 820)

    # ---------- Ìè¨Ìä∏ ----------
    def refresh_ports(self):
        self.port_combo.clear()
        ports = [p.device for p in list_ports.comports()]
        if ports:
            if PORT in ports: ports.remove(PORT); ports.insert(0, PORT)
            self.port_combo.addItems(ports)
        else:
            self.port_combo.addItem("No Ports")

    def on_refresh_clicked(self):
        self.refresh_ports()
        if self.ser is None and not self.streaming_enabled and not self.logging_enabled:
            self.try_open_serial()

    def try_open_serial(self):
        if self.ser:
            try: self.ser.close()
            except Exception: pass
            self.ser = None

        candidates = []
        sel = self.port_combo.currentText() if self.port_combo.count() > 0 else None
        if sel and sel != "No Ports": candidates.append(sel)
        for p in list_ports.comports():
            desc = (p.description or "").lower()
            if "jlink" in desc or "j-link" in desc:
                if p.device not in candidates: candidates.append(p.device)
        if not candidates:
            self.status.showMessage("No serial ports available"); return

        def open_one(port_name: str):
            try:
                ser = serial.Serial(port=port_name, baudrate=BAUDRATE, timeout=0.1, write_timeout=0.2,
                                    bytesize=serial.EIGHTBITS, parity=serial.PARITY_NONE, stopbits=serial.STOPBITS_ONE,
                                    xonxoff=False, rtscts=False, dsrdtr=False)
                try:
                    ser.setDTR(True); ser.setRTS(True)
                    ser.reset_input_buffer(); ser.reset_output_buffer()
                except Exception: pass
                return ser
            except Exception:
                return None

        for port in candidates:
            ser = open_one(port)
            if not ser: continue
            ok = False
            try:
                ser.write(b"on\n"); QtCore.QThread.msleep(200)
                if ser.in_waiting: ok = True
            except Exception: ok = False
            if ok:
                try:
                    ser.write(b"off\n"); QtCore.QThread.msleep(50)
                    ser.reset_input_buffer(); ser.reset_output_buffer()
                except Exception: pass
                self.ser = ser
                idx = self.port_combo.findText(port)
                if idx >= 0: self.port_combo.setCurrentIndex(idx)
                self.status.showMessage(f"Serial opened: {port} @ {BAUDRATE}")
                self.last_rx_time = QtCore.QTime.currentTime()
                return
            else:
                try: ser.close()
                except Exception: pass
        self.status.showMessage("Serial open failed: no responding J-Link CDC port")

    def auto_reconnect_tick(self):
        if self.streaming_enabled or self.logging_enabled: return
        if self.ser is None:
            self.try_open_serial(); return
        now = QtCore.QTime.currentTime()
        elapsed = self.last_rx_time.msecsTo(now)
        if elapsed < 0: elapsed = 0
        if elapsed > 2500:
            try: self.ser.close()
            except Exception: pass
            self.ser = None
            self.try_open_serial()

    def start_reader_thread(self):
        self.reader_stop.clear()
        self.reader_thread = threading.Thread(target=self.reader_loop, daemon=True)
        self.reader_thread.start()

    # ---------- ÏàòÏã† Î£®ÌîÑ ----------
    def reader_loop(self):
        buf = bytearray()
        while not self.reader_stop.is_set():
            if self.ser is None:
                QtCore.QThread.msleep(200); continue
            try:
                chunk = self.ser.read(4096)
                if chunk:
                    self.last_rx_time = QtCore.QTime.currentTime()
                    buf += chunk
                    consumed = 0
                    if PREFER_BINARY:
                        consumed = self.try_parse_frames(buf)
                        if consumed > 0:
                            del buf[:consumed]
                            continue
                    consumed = self.try_parse_csv_lines(buf)
                    if consumed > 0:
                        del buf[:consumed]
                        continue
                    if len(buf) > 8192:
                        drop = self.resync_to_magic(buf)
                        if drop > 0: del buf[:drop]
            except Exception:
                pass

    # ---------- Binary frame ÌååÏÑú ----------
    def try_parse_frames(self, buf: bytearray) -> int:
        i = 0
        while True:
            if len(buf) - i < FRAME_HDR_SIZE: break
            if (buf[i] | (buf[i+1] << 8)) != FRAME_MAGIC:
                i += 1; continue
            try:
                (magic_le, seq, payload_len, ch_mask, flags) = struct.unpack_from(FRAME_HDR_FMT, buf, i)
            except struct.error:
                break
            frame_len = FRAME_HDR_SIZE + payload_len
            if len(buf) - i < frame_len: break

            payload = memoryview(buf)[i+FRAME_HDR_SIZE : i+FRAME_HDR_SIZE+payload_len]

            # Ìå®ÌÇ∑ Î°úÏä§ Ïπ¥Ïö¥Ìä∏
            if self.last_seq is not None:
                expected = (self.last_seq + 1) & 0xFFFF
                missed = (seq - expected) & 0xFFFF
                if missed != 0:
                    with self.rate_lock:
                        self.lost_packets += missed
                        self.loss_since_last += missed
            self.last_seq = seq
            self.total_packets += 1
            with self.rate_lock:
                self.frames_since_last += 1

            # ÌéòÏù¥Î°úÎìú ‚Üí arr4(samples,4)
            if not (flags & FLAG_ASCII_PAYLOAD):
                try:
                    if flags & FLAG_PACKED12:
                        arr1d = unpack_packed12_to_i16(payload)
                    else:
                        cnt = payload_len // 2
                        arr1d = np.frombuffer(payload, dtype='<i2', count=cnt)

                    # ch_mask Ï†ÅÏö©
                    ch_list = [idx for idx in range(4) if (ch_mask >> idx) & 0x1] or [0,1,2,3]
                    n_ch = len(ch_list)
                    blk = (arr1d.size // n_ch) * n_ch
                    if blk != arr1d.size: arr1d = arr1d[:blk]
                    samples = blk // n_ch
                    arr = arr1d.reshape(samples, n_ch)

                    if n_ch != 4:
                        full = np.zeros((samples, 4), dtype=np.int16)
                        for k, ch in enumerate(ch_list):
                            full[:, ch] = arr[:, k]
                        arr4 = full
                    else:
                        arr4 = arr

                    # === ÎÖºÎ¶¨Ï†Å ÏãúÍ∞ÑÏúºÎ°ú xÏ∂ï ÏÉùÏÑ±/ÎàÑÏ†Å ===
                    if self.streaming_enabled and samples > 0:
                        # Î°úÍπÖ ÏãúÏûë Ïãú Í∏∞Ï§Ä ÏãúÍ∞Ñ Í≥†Ï†ï
                        if self.t0_ms is None:
                            self.t0_ms = QtCore.QTime.currentTime().msecsSinceStartOfDay()
                            self.global_row_idx = 0

                        rows = samples
                        # Ìñâ Ïù∏Îç±Ïä§ ‚Üí Ï†àÎåÄ ÏãúÍ∞Ñ(ms)
                        start_idx = self.global_row_idx
                        idxs = start_idx + np.arange(rows, dtype=np.int64)
                        t_ms = (self.t0_ms + idxs * self.t_step_ms).astype(float).tolist()
                        self.global_row_idx += rows

                        cols = [arr4[:, i].tolist() for i in range(4)]
                        for ch in range(4):
                            self.data_queues[ch].extend(cols[ch])
                            self.time_queues[ch].extend(t_ms)

                        if self.logging_enabled and self.csv_writer:
                            seq_col = np.full((rows, 1), "", dtype=object)
                            rows_out = np.hstack([seq_col, arr4.astype(object)]).tolist()
                            self.csv_writer.writerows(rows_out)

                    self.last_spp = arr1d.size
                except Exception:
                    with self.rate_lock:
                        self.malformed_lines += 1
                        self.malformed_since_last += 1
            else:
                try:
                    line = bytes(payload).decode(errors="ignore").strip()
                    self.handle_ascii_line(line)
                except Exception:
                    with self.rate_lock:
                        self.malformed_lines += 1
                        self.malformed_since_last += 1

            i += frame_len
        return i

    # ---------- CSV ÌååÏÑú ----------
    def try_parse_csv_lines(self, buf: bytearray) -> int:
        try:
            data = bytes(buf)
            nl_pos = data.find(b'\n')
            if nl_pos < 0: return 0
            line = data[:nl_pos+1].decode(errors="ignore").strip()
        except Exception:
            return 0

        if '*' in line: line = line.split('*', 1)[0].strip()
        if "," not in line: return nl_pos + 1

        parts = [p.strip() for p in line.split(",")]
        seq = None; values = None
        try:
            if len(parts) == 5:
                seq = int(parts[0]); values = [int(x) for x in parts[1:]]
            elif len(parts) == 4:
                values = [int(x) for x in parts]
            else:
                with self.rate_lock:
                    self.malformed_lines += 1; self.malformed_since_last += 1
        except ValueError:
            with self.rate_lock:
                self.malformed_lines += 1; self.malformed_since_last += 1
            return nl_pos + 1

        if values and len(values) == 4:
            arr4 = np.array(values, dtype=np.int16).reshape(1, 4)
            # CSVÎèÑ ÎèôÏùºÌïú ÎÖºÎ¶¨ ÏãúÍ∞Ñ ÏÇ¨Ïö©
            if self.streaming_enabled:
                if self.t0_ms is None:
                    self.t0_ms = QtCore.QTime.currentTime().msecsSinceStartOfDay()
                    self.global_row_idx = 0
                idx = self.global_row_idx
                t_ms = self.t0_ms + idx * self.t_step_ms
                for ch in range(4):
                    self.data_queues[ch].append(arr4[0, ch])
                    self.time_queues[ch].append(float(t_ms))
                self.global_row_idx += 1
                if self.logging_enabled and self.csv_writer:
                    self.csv_writer.writerow([seq if seq is not None else ""] + values)

            self.total_packets += 1
            with self.rate_lock:
                self.frames_since_last += 1

        return nl_pos + 1

    # ---------- Ïû¨ÎèôÍ∏∞Ìôî ----------
    def resync_to_magic(self, buf: bytearray) -> int:
        for idx in range(max(0, len(buf) - 2048)):
            if idx + 1 < len(buf):
                m = buf[idx] | (buf[idx+1] << 8)
                if m == FRAME_MAGIC:
                    return idx
        return len(buf) // 2

    # ---------- Í∏∞ÌÉÄ ----------
    def handle_ascii_line(self, line: str):
        if PRINT_TO_CONSOLE and line:
            print(f"[ASCII] {line}", flush=True)

    def update_statusbar_stats(self):
        now = QtCore.QTime.currentTime()
        dt_s = max(0.001, self.prev_stats_time.msecsTo(now) / 1000.0)
        with self.rate_lock:
            delta_frames = self.frames_since_last; self.frames_since_last = 0
            delta_loss = self.loss_since_last; self.loss_since_last = 0
            delta_malformed = self.malformed_since_last; self.malformed_since_last = 0
            delta_gaps = self.gaps_since_last; self.gaps_since_last = 0
        rx_fps = delta_frames / dt_s
        total_sps = rx_fps * max(1, self.last_spp)
        per_ch_sps = total_sps / 4.0
        achieve = (total_sps / TARGET_TOTAL_SPS * 100.0) if TARGET_TOTAL_SPS > 0 else 0.0
        target_k = int(TARGET_TOTAL_SPS / 1000)
        mode = "BIN‚ÜíCSV" if PREFER_BINARY else "CSV only"
        self.status.showMessage(
            f"mode={mode} | pkt={self.total_packets} | "
            f"rx‚âà{rx_fps:,.1f} fps  sps‚âà{total_sps:,.1f}  per-ch‚âà{per_ch_sps:,.1f} | "
            f"loss/s‚âà{delta_loss/dt_s:.2f}  malformed/s‚âà{delta_malformed/dt_s:.2f}  gaps/s‚âà{delta_gaps/dt_s:.2f} | "
            f"target({target_k}k)‚âà{achieve:,.1f}%"
        )
        self.prev_stats_time = now

    # ---------- Î≤ÑÌäº/ÌîåÎ°Ø ----------
    def start_logging(self):
        if self.ser is None:
            self.try_open_serial()
            if self.ser is None:
                QtWidgets.QMessageBox.warning(self, "Serial", "Serial open failed.")
                return
        if not self.logging_enabled:
            # ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
            self.total_packets = self.lost_packets = self.malformed_lines = self.gap_count = 0
            self.last_seq = None
            self.t0_ms = None
            self.global_row_idx = 0
            self.data_queues = [deque([], maxlen=MAX_POINTS) for _ in range(4)]
            self.time_queues = [deque([], maxlen=MAX_POINTS) for _ in range(4)]
            with self.rate_lock:
                self.frames_since_last = self.loss_since_last = self.malformed_since_last = self.gaps_since_last = 0
            try:
                self.ser.reset_input_buffer(); self.ser.reset_output_buffer()
            except Exception: pass

            filename = f"adc_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
            self.last_csv_filename = filename
            try:
                self.csv_file = open(filename, "w", newline="")
                self.csv_writer = csv.writer(self.csv_file)
                self.csv_writer.writerow(["SEQ","CH1","CH2","CH3","CH4"])
            except Exception as e:
                QtWidgets.QMessageBox.warning(self, "CSV", f"Failed to open CSV: {e}")
                return
            self.csv_flush_timer = QtCore.QTimer(self)
            self.csv_flush_timer.timeout.connect(lambda: (self.csv_file and self.csv_file.flush()))
            self.csv_flush_timer.start(1000)

            self.logging_enabled = True
            self.streaming_enabled = True
            try: self.ser.write(b"on\n")
            except Exception: pass
            self.status.showMessage(f"üü¢ Logging started ‚Üí {filename}")

    def stop_logging(self):
        if self.logging_enabled:
            try:
                if self.ser: self.ser.write(b"off\n")
            except Exception: pass
        self.logging_enabled = False
        self.streaming_enabled = False
        try:
            if self.csv_flush_timer: self.csv_flush_timer.stop(); self.csv_flush_timer = None
            if self.csv_file:
                self.csv_file.flush(); self.csv_file.close()
        finally:
            self.csv_file = None; self.csv_writer = None
        self.status.showMessage("üõë Logging stopped. CSV file closed.")

    def send_stimulus(self):
        pulses = self.pulse_edit.text().strip()
        period = self.period_edit.text().strip()
        duty   = self.duty_edit.text().strip()
        if not (pulses.isdigit() and period.isdigit() and duty.isdigit()):
            QtWidgets.QMessageBox.warning(self, "Stim", "Invalid input. Use integers."); return
        cmd = f"{pulses},{period},{duty}\n".encode()
        try:
            if self.ser is None: self.try_open_serial()
            if self.ser:
                self.ser.write(cmd)
                self.status.showMessage(f"üì§ Sent stimulus: {pulses},{period},{duty}")
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Serial", f"Write failed: {e}")

    def toggle_channel(self, idx, state):
        self.channel_visible[idx] = (state == QtCore.Qt.Checked)

    def open_csv(self):
        if self.last_csv_filename and os.path.exists(self.last_csv_filename):
            try: os.startfile(self.last_csv_filename)
            except AttributeError:
                import subprocess; opener = "open" if sys.platform == "darwin" else "xdg-open"
                subprocess.call([opener, self.last_csv_filename])
        else:
            QtWidgets.QMessageBox.information(self, "CSV", "No CSV file to open.")

    def create_split_plots(self):
        self.graphics.clear()
        self.plots, self.curves = [], []
        for i in range(4):
            p = self.graphics.addPlot(row=i, col=0)
            p.showGrid(x=True, y=True)
            p.setLabel("left", f"CH{i+1}", units="V")
            if i == 3:
                p.setLabel("bottom", "Time", units="ms")
            p.getAxis("left").setScale(1e-3)
            p.setYRange(Y_MIN, Y_MAX)
            p.setMouseEnabled(x=True, y=True)
            curve = p.plot([], [], pen=None, symbol='o', symbolSize=4,
                           symbolBrush=CHANNEL_COLORS[i], symbolPen=None)
            self.plots.append(p); self.curves.append(curve)

    def toggle_merge_split(self):
        self.graphics.clear()
        if not self.merged:
            p = self.graphics.addPlot(row=0, col=0)
            p.showGrid(x=True, y=True)
            p.setLabel("left", "Voltage", units="V")
            p.setLabel("bottom", "Time", units="ms")
            p.getAxis("left").setScale(1e-3)
            p.setYRange(Y_MIN, Y_MAX)
            p.setMouseEnabled(x=True, y=True)
            self.curves = []
            for i in range(4):
                self.curves.append(p.plot([], [], pen=None, symbol='o', symbolSize=4,
                                          symbolBrush=CHANNEL_COLORS[i], symbolPen=None, name=f"CH{i+1}"))
            self.merged = True; self.btn_merge_split.setText("Split")
        else:
            self.create_split_plots()
            self.merged = False; self.btn_merge_split.setText("Merge")

    def reset_view(self):
        if self.merged:
            if self.curves:
                vb = self.curves[0].getViewBox(); vb.setYRange(Y_MIN, Y_MAX)
        else:
            for c in self.curves:
                vb = c.getViewBox(); vb.setYRange(Y_MIN, Y_MAX)
        self.status.showMessage("üîÑ View reset")

    def update_plot(self):
        for i, curve in enumerate(self.curves):
            if self.channel_visible[i]:
                dq = self.data_queues[i]; tq = self.time_queues[i]
                if dq:
                    y = np.fromiter(dq, dtype=np.int16, count=len(dq))
                    x = np.fromiter(tq, dtype=float, count=len(tq))
                    curve.setData(x, y, pen=None)
                else:
                    curve.setData([], [], pen=None)
            else:
                curve.setData([], [], pen=None)

    def cleanup(self):
        self.reader_stop.set()
        if self.reader_thread and self.reader_thread.is_alive():
            try: self.reader_thread.join(timeout=1.0)
            except Exception: pass
        if self.csv_flush_timer:
            try: self.csv_flush_timer.stop()
            except Exception: pass
        if self.csv_file:
            try: self.csv_file.flush(); self.csv_file.close()
            except Exception: pass
        if self.ser:
            try: self.ser.close()
            except Exception: pass

def main():
    app = QtWidgets.QApplication(sys.argv)
    pg.setConfigOptions(antialias=True, useOpenGL=False)
    win = MainWindow(); win.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
