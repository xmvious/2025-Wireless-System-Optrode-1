/*
 * Peripheral NUS + SAADC EasyDMA Streaming (High-Performance)
 * NCS v2.9.0 / Zephyr 3.7.x
 *
 * - NRFX HAL drivers for continuous SAADC sampling using Timer/PPI.
 * - Double-buffering with large buffers for high-speed data acquisition.
 * - Each frame contains 500 sample sets (500 * 4ch * 2 bytes = 4000 bytes).
 * - Decouples data acquisition (IRQ) from data transmission (workqueue).
 */

#include <errno.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include <zephyr/kernel.h>
#include <zephyr/device.h>
#include <zephyr/devicetree.h>
#include <zephyr/types.h>

#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/uuid.h>
#include <zephyr/bluetooth/gatt.h>
#include <zephyr/bluetooth/hci.h>
#include <bluetooth/services/nus.h>

#include <zephyr/settings/settings.h>
#include <zephyr/logging/log.h>
#include <dk_buttons_and_leds.h>

#include <zephyr/sys/byteorder.h>
#include <zephyr/sys/util.h>

/* === NRFX HAL 드라이버 헤더 === */
#include <hal/nrf_gpio.h>
#include <hal/nrf_saadc.h>
#include <hal/nrf_timer.h>
#include <nrfx.h>
#include <nrfx_timer.h>
#include <nrfx_ppi.h>
#include <nrfx_saadc.h>

LOG_MODULE_REGISTER(peripheral_nus_saadc, LOG_LEVEL_INF);

/* =====================[ 프레이밍 및 프로젝트 설정 ]===================== */
#define FRAME_MAGIC              0xA5C3
#define FLAG_ASCII_PAYLOAD       0x01

// 16kHz 샘플링 레이트
#define SAMPLE_RATE_HZ           16000
// 활성화할 채널 수
#define NUM_CHANNELS             4
// ★★★ 한 프레임에 담을 샘플 세트 수 ★★★
#define SAMPLES_PER_FRAME        500
// 버퍼당 총 샘플 수 (4채널 * 500 = 2000)
#define TOTAL_SAMPLES_PER_BUF    (NUM_CHANNELS * SAMPLES_PER_FRAME)

/* ADC 채널 핀맵 (보드에 맞게 조정) */
#define AIN0 NRF_SAADC_INPUT_AIN2 // A2
#define AIN1 NRF_SAADC_INPUT_AIN4 // A4
#define AIN2 NRF_SAADC_INPUT_AIN5 // A5
#define AIN3 NRF_SAADC_INPUT_AIN6 // A6

typedef struct __packed {
    uint16_t magic;
    uint16_t seq;           /* LE */
    uint16_t payload_len;   /* LE */
    uint8_t  ch_mask;
    uint8_t  flags;
} frame_hdr_t;

/* =====================[ 전역 변수 ]===================== */
static struct bt_conn *current_conn;
static uint16_t g_seq = 0;
static uint16_t att_mtu = 23;

/* SAADC EasyDMA를 위한 더블 버퍼 (4000 바이트 * 2개) */
static int16_t m_saadc_buf0[TOTAL_SAMPLES_PER_BUF];
static int16_t m_saadc_buf1[TOTAL_SAMPLES_PER_BUF];

/* NRFX 드라이버 인스턴스 */
static const nrfx_timer_t m_timer = NRFX_TIMER_INSTANCE(1);
static nrf_ppi_channel_t  m_ppi_ch;

/* SAADC 데이터 처리를 위한 워크큐와 메시지큐 */
static struct k_work saadc_work;
struct sample_buffer_t { int16_t *buf; size_t len; };
K_MSGQ_DEFINE(saadc_msgq, sizeof(struct sample_buffer_t), 4, 4);

/* 스트리밍 상태 */
static volatile bool m_streaming = false;

/* =====================[ 전방 선언 ]===================== */
static int start_streaming(void);
static void stop_streaming(void);
static void saadc_work_handler(struct k_work *w);

/* =====================[ BLE NUS 및 연결 관리 ]===================== */
K_SEM_DEFINE(nus_write_sem, 0, 1);

static const struct bt_data ad[] = {
    BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)),
    BT_DATA(BT_DATA_NAME_COMPLETE, CONFIG_BT_DEVICE_NAME, (sizeof(CONFIG_BT_DEVICE_NAME) - 1)),
};

static const struct bt_data sd[] = {
    BT_DATA_BYTES(BT_DATA_UUID128_ALL, BT_UUID_NUS_VAL),
};

static void nus_sent_cb(struct bt_conn *conn) { k_sem_give(&nus_write_sem); }

static int nus_send_chunked(const uint8_t *p, uint16_t len) {
    if (!current_conn) return -ENOTCONN;
    uint16_t max_chunk = (att_mtu > 3) ? (att_mtu - 3) : 20;
    while (len) {
        uint16_t n = MIN(max_chunk, len);
        int err = bt_nus_send(current_conn, p, n);
        if (err) return err;
        if (k_sem_take(&nus_write_sem, K_MSEC(150))) { LOG_WRN("NUS send timeout"); }
        p += n; len -= n;
    }
    return 0;
}

static int send_frame_over_nus(const uint8_t *payload, uint16_t payload_len) {
    const uint16_t total = sizeof(frame_hdr_t) + payload_len;
    uint8_t *frame = k_malloc(total);
    if (!frame) return -ENOMEM;

    frame_hdr_t hdr = {
        .magic = sys_cpu_to_le16(FRAME_MAGIC),
        .seq = sys_cpu_to_le16(g_seq++),
        .payload_len = sys_cpu_to_le16(payload_len),
        .ch_mask = ((1 << NUM_CHANNELS) - 1),
        .flags = 0,
    };
    memcpy(frame, &hdr, sizeof(hdr));
    memcpy(frame + sizeof(hdr), payload, payload_len);

    int err = nus_send_chunked(frame, total);
    k_free(frame);
    return err;
}

static void nus_receive_cb(struct bt_conn *conn, const uint8_t *data, uint16_t len) {
    char temp_str[64];
    size_t n = MIN(len, sizeof(temp_str) - 1);
    memcpy(temp_str, data, n);
    temp_str[n] = '\0';

    if (strcmp(temp_str, "on") == 0) {
        start_streaming();
    } else if (strcmp(temp_str, "off") == 0) {
        stop_streaming();
    }
}

static struct bt_nus_cb nus_cb = { .received = nus_receive_cb, .sent = nus_sent_cb };

static void connected(struct bt_conn *conn, uint8_t err) {
    if (err) { LOG_ERR("Connection failed (err %u)", err); return; }
    LOG_INF("Connected");
    current_conn = bt_conn_ref(conn);
    dk_set_led_on(DK_LED2);
    att_mtu = bt_gatt_get_mtu(conn);
}

static void disconnected(struct bt_conn *conn, uint8_t reason) {
    LOG_INF("Disconnected (reason %u)", reason);
    if (current_conn) {
        bt_conn_unref(current_conn);
        current_conn = NULL;
        dk_set_led_off(DK_LED2);
        stop_streaming();
    }
}

BT_CONN_CB_DEFINE(conn_callbacks) = { .connected = connected, .disconnected = disconnected };

/* =====================[ SAADC 고속 샘플링 로직 ]===================== */

void nrfx_saadc_event_handler(nrfx_saadc_evt_t const *p_event) {
    if (p_event->type == NRFX_SAADC_EVT_DONE) {
        const int16_t *p_buffer = (const int16_t *)p_event->data.done.p_buffer;
        (void)nrfx_saadc_buffer_set((int16_t *)p_buffer, TOTAL_SAMPLES_PER_BUF);

        struct sample_buffer_t msg = { .buf = (int16_t *)p_buffer, .len = p_event->data.done.size };
        if (k_msgq_put(&saadc_msgq, &msg, K_NO_WAIT) != 0) {
            LOG_WRN("SAADC msgq full, data dropped!");
        }
        k_work_submit(&saadc_work);
    }
}

static void saadc_work_handler(struct k_work *w) {
    struct sample_buffer_t msg;
    while (k_msgq_get(&saadc_msgq, &msg, K_NO_WAIT) == 0) {
        if (m_streaming && current_conn) {
            int err = send_frame_over_nus((uint8_t *)msg.buf, msg.len * sizeof(int16_t));
            if (err) {
                LOG_WRN("send_frame_over_nus failed, err: %d", err);
            }
        }
    }
}

static void timer_config_start(uint32_t sample_rate_hz) {
    nrfx_timer_uninit(&m_timer);
    // ★★★★★ 수정된 부분 1: NRFX_TIMER_DEFAULT_CONFIG 매크로 대신 직접 초기화
    nrfx_timer_config_t cfg = {
        .frequency          = NRF_TIMER_FREQ_1MHz,
        .mode               = NRF_TIMER_MODE_TIMER,
        .interrupt_priority = NRFX_TIMER_DEFAULT_CONFIG_IRQ_PRIORITY,
        .p_context          = NULL
    };

    NRFX_ASSERT(nrfx_timer_init(&m_timer, &cfg, NULL) == NRFX_SUCCESS);

    uint32_t period_us = 1000000UL / sample_rate_hz;
    uint32_t ticks = nrfx_timer_us_to_ticks(&m_timer, period_us);
    nrfx_timer_extended_compare(&m_timer, NRF_TIMER_CC_CHANNEL0, ticks, NRF_TIMER_SHORT_COMPARE0_CLEAR_MASK, false);
    nrfx_timer_enable(&m_timer);
}

static void ppi_connect_timer_to_saadc(void) {
    uint32_t timer_event = nrfx_timer_event_address_get(&m_timer, NRF_TIMER_EVENT_COMPARE0);
    uint32_t saadc_task  = nrf_saadc_task_address_get(NRF_SAADC, NRF_SAADC_TASK_SAMPLE);
    NRFX_ASSERT(nrfx_ppi_channel_alloc(&m_ppi_ch) == NRFX_SUCCESS);
    NRFX_ASSERT(nrfx_ppi_channel_assign(m_ppi_ch, timer_event, saadc_task) == NRFX_SUCCESS);
    NRFX_ASSERT(nrfx_ppi_channel_enable(m_ppi_ch) == NRFX_SUCCESS);
}

int start_streaming(void) {
    if (m_streaming) return 0;

    // ★★★★★ 수정된 부분 2: NRFX_SAADC_DEFAULT_CHANNEL_CONFIG_SE 매크로 대신 직접 초기화
    nrf_saadc_channel_config_t ch_cfg = {
        .gain       = NRF_SAADC_GAIN1_6,
        .reference  = NRF_SAADC_REFERENCE_VDD4,
        .acq_time   = NRF_SAADC_ACQTIME_10US,
        .mode       = NRF_SAADC_MODE_SINGLE_ENDED,
        .burst      = NRF_SAADC_BURST_ENABLED,
        .resistor_p = NRF_SAADC_RESISTOR_DISABLED,
        .resistor_n = NRF_SAADC_RESISTOR_DISABLED
    };

    nrfx_saadc_channel_t channels[] = {
        { .channel_config = ch_cfg, .pin_p = AIN0, .channel_index = 0 },
        { .channel_config = ch_cfg, .pin_p = AIN1, .channel_index = 1 },
        { .channel_config = ch_cfg, .pin_p = AIN2, .channel_index = 2 },
        { .channel_config = ch_cfg, .pin_p = AIN3, .channel_index = 3 },
    };
    
    nrfx_err_t err = nrfx_saadc_init(NRFX_SAADC_DEFAULT_CONFIG_IRQ_PRIORITY);
    if (err != NRFX_SUCCESS) { LOG_ERR("nrfx_saadc_init failed: %d", err); return -EIO; }

    NRFX_ASSERT(nrfx_saadc_channels_config(channels, NUM_CHANNELS) == NRFX_SUCCESS);

    NRFX_ASSERT(nrfx_saadc_buffer_set(m_saadc_buf0, TOTAL_SAMPLES_PER_BUF) == NRFX_SUCCESS);
    NRFX_ASSERT(nrfx_saadc_buffer_set(m_saadc_buf1, TOTAL_SAMPLES_PER_BUF) == NRFX_SUCCESS);
    
    timer_config_start(SAMPLE_RATE_HZ * NUM_CHANNELS);
    ppi_connect_timer_to_saadc();

    nrf_saadc_task_trigger(NRF_SAADC, NRF_SAADC_TASK_START);

    m_streaming = true;
    LOG_INF("Streaming started");
    return 0;
}

void stop_streaming(void) {
    if (!m_streaming) return;

    nrfx_timer_disable(&m_timer);
    (void)nrfx_ppi_channel_disable(m_ppi_ch);
    nrfx_ppi_channel_free(m_ppi_ch);
    nrfx_saadc_uninit();

    m_streaming = false;
    LOG_INF("Streaming stopped");
}

/* =====================[ main ]===================== */
int main(void) {
    int err;

    dk_leds_init();
    k_work_init(&saadc_work, saadc_work_handler);

    err = bt_enable(NULL);
    if (err) { LOG_ERR("Bluetooth init failed (err %d)", err); return 0; }
    LOG_INF("Bluetooth initialized");

    if (IS_ENABLED(CONFIG_SETTINGS)) { settings_load(); }

    err = bt_nus_init(&nus_cb);
    if (err) { LOG_ERR("Failed to initialize UART service (err: %d)", err); return 0; }

    err = bt_le_adv_start(BT_LE_ADV_CONN, ad, ARRAY_SIZE(ad), sd, ARRAY_SIZE(sd));
    if (err) { LOG_ERR("Advertising failed to start (err %d)", err); return 0; }
    LOG_INF("Advertising started");

    int blink_status = 0;
    while (1) {
        dk_set_led(DK_LED1, (++blink_status) % 2);
        k_sleep(K_MSEC(1000));
    }
    return 0;
}
