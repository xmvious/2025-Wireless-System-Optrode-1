# -*- coding: utf-8 -*-
"""
PyQt5 + PyQtGraph 기반 4채널 실시간 플로터 (실제 시간 축 적용)
- 기본 입력: 바이너리 프레임
  header: 0xC3 0xA5 | seq(LE16) | payload_len(LE16) | ch_mask(u8) | flags(u8)
  payload: int16 LE × 4 (CH1..CH4)  [필요시 확장 가능]
- 하위호환: "v1,v2,v3,v4\n" 또는 "seq,v1,v2,v3,v4\n" 문자열도 파싱
- Start: 'on\n' 전송 + CSV 로깅 시작 (CSV 헤더: SEQ,CH1..CH4)
- Stop : 'off\n' 전송 + CSV 로깅 종료
- Stim : "pulses,period,duty\n" 전송
- CH1~CH4 가시성 토글, Merge/Split 지원, 콘솔 실시간 출력
- 패킷 누락(lost) 및 간격 기반 갭(gap) 감지/표시
- 상태바에 rx pkt/s, 총 sps, per-ch sps, target(16k) 달성률
"""

import sys
import os
import csv
import struct
import threading
import time # <<< 수정: time 모듈 추가
from threading import Lock
from collections import deque
from datetime import datetime

import serial
from serial import SerialException
from serial.tools import list_ports

import pyqtgraph as pg
from PyQt5 import QtWidgets, QtCore

# ===== 설정 =====
PORT = "COM3"             # 초기 선택용 기본 포트
BAUDRATE = 115200         # 권장: 1_000_000 이상 (보드/드라이버 가능 시)
MAX_POINTS = 500
UPDATE_INTERVAL_MS = 100
Y_MIN, Y_MAX = 0, 3000
CHANNEL_COLORS = ['r', 'g', 'b', 'y']

SAMPLES_PER_PACKET = 4      # 프레임 1개에 4채널 1샘플
TARGET_TOTAL_SPS = 16000
PRINT_TO_CONSOLE = True

# ===== Binary Frame 정의 =====
FRAME_MAGIC = 0xA5C3
FRAME_HDR_FMT = "<HHHBB"      # magic, seq, payload_len, ch_mask, flags (little-endian)
FRAME_HDR_SIZE = struct.calcsize(FRAME_HDR_FMT)
FLAG_ASCII_PAYLOAD = 0x01

# ===== CSV 호환 여부 자동 감지 =====
PREFER_BINARY = True          # True면 먼저 바이너리 시도, 안 맞으면 CSV 줄도 병행 파싱


class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Live ADC Data (4CH) - Real-Time Axis")

        # 상태 변수
        self.data_queues = [deque(maxlen=MAX_POINTS) for _ in range(4)] # <<< 수정: 이제 (시간, 값) 튜플을 저장
        self.channel_visible = [True, True, True, True]
        self.logging_enabled = False
        self.streaming_enabled = False
        self.csv_file = None
        self.csv_writer = None
        self.last_csv_filename = None
        self.ser = None
        self.reader_thread = None
        self.reader_stop = threading.Event()
        self.merged = False

        # 통계/감시
        self.total_packets = 0
        self.lost_packets = 0
        self.malformed_lines = 0
        self.gap_count = 0
        self.last_seq = None
        self.last_time = None
        self.dt_history = deque(maxlen=200)

        # 레이트 계산(스레드-세이프)
        self.pkts_since_last = 0
        self.rate_lock = Lock()
        self.prev_stats_time = QtCore.QTime.currentTime()

        # ========== UI ==========
        central = QtWidgets.QWidget()
        self.setCentralWidget(central)
        vbox = QtWidgets.QVBoxLayout(central)

        ctrl = QtWidgets.QHBoxLayout()

        # Port 선택
        ctrl.addWidget(QtWidgets.QLabel("Port"))
        self.port_combo = QtWidgets.QComboBox()
        self.refresh_ports()
        ctrl.addWidget(self.port_combo)

        # Stim 파라미터
        ctrl.addWidget(QtWidgets.QLabel("Pulse"))
        self.pulse_edit = QtWidgets.QLineEdit(); self.pulse_edit.setFixedWidth(70); ctrl.addWidget(self.pulse_edit)
        ctrl.addWidget(QtWidgets.QLabel("Period"))
        self.period_edit = QtWidgets.QLineEdit(); self.period_edit.setFixedWidth(70); ctrl.addWidget(self.period_edit)
        ctrl.addWidget(QtWidgets.QLabel("Duty"))
        self.duty_edit = QtWidgets.QLineEdit(); self.duty_edit.setFixedWidth(70); ctrl.addWidget(self.duty_edit)

        self.btn_stim = QtWidgets.QPushButton("Stim"); self.btn_stim.clicked.connect(self.send_stimulus); ctrl.addWidget(self.btn_stim)
        ctrl.addStretch()

        # Start/Stop
        self.btn_start = QtWidgets.QPushButton("Start"); self.btn_start.clicked.connect(self.start_logging); ctrl.addWidget(self.btn_start)
        self.btn_stop  = QtWidgets.QPushButton("Stop");  self.btn_stop.clicked.connect(self.stop_logging);  ctrl.addWidget(self.btn_stop)

        # Merge/Split + Reset
        self.btn_merge_split = QtWidgets.QPushButton("Merge"); self.btn_merge_split.clicked.connect(self.toggle_merge_split); ctrl.addWidget(self.btn_merge_split)
        self.btn_reset = QtWidgets.QPushButton("Reset View"); self.btn_reset.clicked.connect(self.reset_view); ctrl.addWidget(self.btn_reset)

        # 채널 토글
        self.cb_ch = []
        for i in range(4):
            cb = QtWidgets.QCheckBox(f"CH{i+1}")
            cb.setChecked(True)
            cb.stateChanged.connect(lambda state, idx=i: self.toggle_channel(idx, state))
            self.cb_ch.append(cb); ctrl.addWidget(cb)

        # Open CSV
        self.btn_open = QtWidgets.QPushButton("Open CSV"); self.btn_open.clicked.connect(self.open_csv); ctrl.addWidget(self.btn_open)
        vbox.addLayout(ctrl)

        # 그래프
        self.graphics = pg.GraphicsLayoutWidget(); vbox.addWidget(self.graphics)
        self.create_split_plots()

        # 상태바
        self.status = self.statusBar(); self.status.showMessage("Ready (mode: BIN first, CSV fallback)")

        # 타이머들
        self.timer = QtCore.QTimer(self); self.timer.timeout.connect(self.update_plot); self.timer.start(UPDATE_INTERVAL_MS)
        self.stats_timer = QtCore.QTimer(self); self.stats_timer.timeout.connect(self.update_statusbar_stats); self.stats_timer.start(1000)

        # 시리얼 & 리더 스레드
        self.try_open_serial()
        self.start_reader_thread()

        self.destroyed.connect(self.cleanup)
        self.resize(1000, 800)

    # ----- 포트 -----
    def refresh_ports(self):
        self.port_combo.clear()
        ports = [p.device for p in list_ports.comports()]
        if ports:
            if PORT in ports:
                ports.remove(PORT); ports.insert(0, PORT)
            self.port_combo.addItems(ports)
        else:
            self.port_combo.addItem("No Ports")

    def try_open_serial(self):
        port_name = self.port_combo.currentText() if self.port_combo.count() > 0 else None
        if not port_name or port_name == "No Ports":
            self.status.showMessage("No serial ports available"); return
        if self.ser:
            try: self.ser.close()
            except Exception: pass
            self.ser = None
        try:
            self.ser = serial.Serial(port_name, BAUDRATE, timeout=0.05)  # 짧은 timeout
            self.status.showMessage(f"Serial opened: {port_name} @ {BAUDRATE}")
        except SerialException as e:
            self.ser = None
            self.status.showMessage(f"Serial open failed: {e}")

    def start_reader_thread(self):
        self.reader_stop.clear()
        self.reader_thread = threading.Thread(target=self.reader_loop, daemon=True)
        self.reader_thread.start()

    # ----- 수신 루프 (바이너리 우선 + CSV 백업) -----
    def reader_loop(self):
        buf = bytearray()
        while not self.reader_stop.is_set():
            if self.ser is None:
                QtCore.QThread.msleep(200); continue
            try:
                chunk = self.ser.read(4096)
                if chunk:
                    buf += chunk
                    # 1) 먼저 바이너리 프레임 시도
                    if PREFER_BINARY:
                        consumed = self.try_parse_frames(buf)
                        if consumed > 0:
                            del buf[:consumed]
                            continue
                    # 2) CSV 줄 파싱 (개행 기준)
                    consumed = self.try_parse_csv_lines(buf)
                    if consumed > 0:
                        del buf[:consumed]
                        continue
                    # 3) 버퍼 과도 성장 방지: magic 검색 후 앞부분 버림
                    if len(buf) > 8192:
                        drop = self.resync_to_magic(buf)
                        if drop > 0:
                            del buf[:drop]
            except Exception:
                pass  # 잡음 등 무시

    # ----- Binary Frame 파서 -----
    def try_parse_frames(self, buf: bytearray) -> int:
        """가능한 만큼 프레임을 파싱하고 소비한 바이트 수를 반환"""
        i = 0
        consumed_total = 0
        while True:
            if len(buf) - i < FRAME_HDR_SIZE:
                break
            # magic 검사 (LE)
            magic = buf[i] | (buf[i+1] << 8)
            if magic != FRAME_MAGIC:
                i += 1
                continue
            # 헤더 파싱
            try:
                (magic_le, seq, payload_len, ch_mask, flags) = struct.unpack_from(FRAME_HDR_FMT, buf, i)
            except struct.error:
                break
            frame_len = FRAME_HDR_SIZE + payload_len
            if len(buf) - i < frame_len:
                break  # 더 읽어야 함

            payload = memoryview(buf)[i+FRAME_HDR_SIZE : i+FRAME_HDR_SIZE+payload_len]

            # flags 처리: ASCII payload 지원(옵션)
            if flags & FLAG_ASCII_PAYLOAD:
                try:
                    line = bytes(payload).decode(errors="ignore").strip()
                    self.handle_ascii_line(line)
                except Exception:
                    self.malformed_lines += 1
            else:
                # payload를 4채널 int16 LE로 가정
                if payload_len < 8:
                    self.malformed_lines += 1
                else:
                    try:
                        v1, v2, v3, v4 = struct.unpack_from("<hhhh", payload, 0)
                        self.handle_sample(seq, [v1, v2, v3, v4])
                    except struct.error:
                        self.malformed_lines += 1

            i += frame_len
            consumed_total = i
        return consumed_total

    # ----- CSV 줄 파서 (하위호환) -----
    def try_parse_csv_lines(self, buf: bytearray) -> int:
        try:
            data = bytes(buf)
            nl_pos = data.find(b'\n')
            if nl_pos < 0:
                return 0
            line = data[:nl_pos+1].decode(errors="ignore").strip()
        except Exception:
            return 0

        # 체크섬 제거
        if '*' in line:
            line = line.split('*', 1)[0].strip()
        if "," not in line:
            return nl_pos + 1

        parts = [p.strip() for p in line.split(",")]
        seq = None; values = None
        try:
            if len(parts) == 5:
                seq = int(parts[0]); values = [int(x) for x in parts[1:]]
            elif len(parts) == 4:
                values = [int(x) for x in parts]
            else:
                self.malformed_lines += 1
        except ValueError:
            self.malformed_lines += 1
            return nl_pos + 1

        if values and len(values) == 4:
            self.handle_sample(seq, values)

        return nl_pos + 1

    # ----- magic 재동기화 -----
    def resync_to_magic(self, buf: bytearray) -> int:
        """버퍼에서 magic(LE)을 찾아 그 전까지 버림"""
        for idx in range(max(0, len(buf) - 2048)):
            if idx + 1 < len(buf):
                m = buf[idx] | (buf[idx+1] << 8)
                if m == FRAME_MAGIC:
                    return idx
        # 못 찾으면 절반 버림
        return len(buf) // 2

    # ----- 샘플 처리 공통 -----
    def handle_sample(self, seq, values):
        timestamp = time.time() # <<< 수정: 현재 시간 기록
        now = QtCore.QTime.currentTime()

        # 콘솔 출력
        if PRINT_TO_CONSOLE:
            if seq is not None:
                print(f"{seq},{values[0]},{values[1]},{values[2]},{values[3]}", flush=True)
            else:
                print(f"{values[0]},{values[1]},{values[2]},{values[3]}", flush=True)

        # 갭 감지
        if self.last_time is not None:
            dt_ms = self.last_time.msecsTo(now)
            if dt_ms >= 0:
                self.dt_history.append(dt_ms)
                if len(self.dt_history) >= 20:
                    median_dt = sorted(self.dt_history)[len(self.dt_history)//2]
                    threshold = max(10, 3 * median_dt)
                    if dt_ms > threshold:
                        self.gap_count += 1
                        if PRINT_TO_CONSOLE:
                            print(f"[GAP] dt={dt_ms}ms (>~{threshold}ms)", flush=True)
        self.last_time = now

        # 누락 감지
        if seq is not None:
            if self.last_seq is not None:
                expected = (self.last_seq + 1) & 0xFFFF
                missed = (seq - expected) & 0xFFFF
                if missed != 0:
                    self.lost_packets += missed
                    if PRINT_TO_CONSOLE:
                        print(f"[LOSS] missed {missed} pkt(s): last={self.last_seq}, got={seq}", flush=True)
            self.last_seq = seq

        # 누적 및 1초 창 누적
        self.total_packets += 1
        with self.rate_lock:
            self.pkts_since_last += 1

        # 그래프/로깅
        if self.streaming_enabled:
            for i in range(4):
                self.data_queues[i].append((timestamp, values[i])) # <<< 수정: (시간, 값) 튜플로 저장
            if self.logging_enabled and self.csv_writer:
                if seq is not None: self.csv_writer.writerow([seq] + values)
                else:               self.csv_writer.writerow([""] + values)

    # ----- ASCII 명령 처리 (flags & 0x01일 때) -----
    def handle_ascii_line(self, line: str):
        if not line:
            return
        # 여기서는 모니터용 출력만—보드로 역전송은 안 함
        if PRINT_TO_CONSOLE:
            print(f"[ASCII] {line}", flush=True)

        # 필요 시 'on','off','pulse,period,duty' 같은 문자열을 받아
        # UI 상태를 바꾸거나 로그에 남길 수 있음(선택).

    # ----- 상태바 -----
    def update_statusbar_stats(self):
        now = QtCore.QTime.currentTime()
        dt_s = max(0.001, self.prev_stats_time.msecsTo(now) / 1000.0)
        with self.rate_lock:
            delta_pkts = self.pkts_since_last
            self.pkts_since_last = 0
        rx_pkt_s = delta_pkts / dt_s

        total_sps = rx_pkt_s * SAMPLES_PER_PACKET
        per_ch_sps = total_sps / 4.0
        achieve = (total_sps / TARGET_TOTAL_SPS * 100.0) if TARGET_TOTAL_SPS > 0 else 0.0

        mode = "BIN→CSV" if PREFER_BINARY else "CSV only"
        self.status.showMessage(
            f"mode={mode} | pkt={self.total_packets}  loss={self.lost_packets}  malformed={self.malformed_lines}  gaps={self.gap_count}  |  "
            f"rx≈{rx_pkt_s:,.1f}/s  sps≈{total_sps:,.1f}  per-ch≈{per_ch_sps:,.1f}  |  target(16k)≈{achieve:,.1f}%"
        )
        self.prev_stats_time = now

    # ----- 버튼 핸들러 -----
    def start_logging(self):
        if self.ser is None:
            self.try_open_serial()
            if self.ser is None:
                QtWidgets.QMessageBox.warning(self, "Serial", "Serial open failed."); return
        if not self.logging_enabled:
            filename = f"adc_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
            self.last_csv_filename = filename
            try:
                self.csv_file = open(filename, mode="w", newline="")
                self.csv_writer = csv.writer(self.csv_file)
                self.csv_writer.writerow(["SEQ", "CH1", "CH2", "CH3", "CH4"])
            except Exception as e:
                QtWidgets.QMessageBox.warning(self, "CSV", f"Failed to open CSV: {e}"); return
            try:
                self.ser.write(b"on\n")   # 보드로 ASCII 명령 전송(현 구조 유지)
            except Exception:
                pass
            self.logging_enabled = True
            self.streaming_enabled = True
            self.status.showMessage(f"🟢 Logging started → {filename}")

    def stop_logging(self):
        if self.logging_enabled:
            try:
                if self.ser: self.ser.write(b"off\n")
            except Exception:
                pass
        self.logging_enabled = False
        self.streaming_enabled = False
        try:
            if self.csv_file: self.csv_file.close()
        finally:
            self.csv_file = None; self.csv_writer = None
        self.status.showMessage("🛑 Logging stopped. CSV file closed.")

    def send_stimulus(self):
        pulses = self.pulse_edit.text().strip()
        period = self.period_edit.text().strip()
        duty   = self.duty_edit.text().strip()
        if not (pulses.isdigit() and period.isdigit() and duty.isdigit()):
            QtWidgets.QMessageBox.warning(self, "Stim", "Invalid input. Use integers."); return
        cmd = f"{pulses},{period},{duty}\n".encode()
        try:
            if self.ser is None: self.try_open_serial()
            if self.ser:
                self.ser.write(cmd)   # ASCII 명령 전송(하위호환)
                self.status.showMessage(f"📤 Sent stimulus: {pulses},{period},{duty}")
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Serial", f"Write failed: {e}")

    def toggle_channel(self, idx, state):
        self.channel_visible[idx] = (state == QtCore.Qt.Checked)

    def open_csv(self):
        if self.last_csv_filename and os.path.exists(self.last_csv_filename):
            try: os.startfile(self.last_csv_filename)
            except AttributeError:
                import subprocess; opener = "open" if sys.platform == "darwin" else "xdg-open"
                subprocess.call([opener, self.last_csv_filename])
        else:
            QtWidgets.QMessageBox.information(self, "CSV", "No CSV file to open.")

    # ----- 그래프 -----
    def create_split_plots(self):
        self.graphics.clear()
        self.plots, self.curves = [], []
        for i in range(4):
            # <<< 수정: 루프 안에서 매번 새로운 DateAxisItem을 생성합니다.
            axis_items = {'bottom': pg.DateAxisItem()}
            p = self.graphics.addPlot(row=i, col=0, axisItems=axis_items)
            p.showGrid(x=True, y=True)
            p.setLabel("left", f"CH{i+1}", units="V")

            # <<< 추가: 첫 번째 플롯(i=0)이 아닌 경우, X축을 첫 번째 플롯에 연결(link)합니다.
            # 이렇게 하면 모든 플롯의 시간 축이 함께 움직입니다.
            if i > 0:
                p.setXLink(self.plots[0])

            # 마지막 플롯에만 X축 라벨을 표시하여 깔끔하게 만듭니다.
            if i == 3:
                p.setLabel("bottom", "Time")
            else:
                # 나머지 플롯들의 X축 눈금 라벨은 숨겨서 더 깔끔하게 보입니다.
                p.getAxis('bottom').setStyle(showValues=False)

            p.getAxis("left").setScale(1e-3)
            p.setYRange(Y_MIN, Y_MAX)
            p.setMouseEnabled(x=True, y=True)
            curve = p.plot([], [], pen=CHANNEL_COLORS[i])
            self.plots.append(p) # p.setXLink를 사용하려면 이 줄이 curve 추가보다 먼저 와야 합니다.
            self.curves.append(curve)

    def toggle_merge_split(self):
        self.graphics.clear()
        if not self.merged:
            axis_items = {'bottom': pg.DateAxisItem()} # <<< 수정: 시간 축 아이템 생성
            p = self.graphics.addPlot(row=0, col=0, axisItems=axis_items) # <<< 수정: 시간 축 적용
            p.showGrid(x=True, y=True)
            p.setLabel("left", "Voltage", units="V")
            p.setLabel("bottom", "Time") # <<< 수정: 단위 삭제
            p.getAxis("left").setScale(1e-3)
            # p.getAxis("bottom").setScale(1e-3) # <<< 수정: 이 줄 삭제
            p.setYRange(Y_MIN, Y_MAX)
            p.setMouseEnabled(x=True, y=True)
            self.curves = []
            for i in range(4):
                self.curves.append(p.plot([], [], pen=CHANNEL_COLORS[i], name=f"CH{i+1}"))
            self.merged = True; self.btn_merge_split.setText("Split")
        else:
            self.create_split_plots()
            self.merged = False; self.btn_merge_split.setText("Merge")

    def reset_view(self):
        if self.merged:
            if self.curves:
                vb = self.curves[0].getViewBox()
                # vb.setXRange(0, MAX_POINTS) # <<< 수정: X축 범위 수동 설정 삭제
                vb.setYRange(Y_MIN, Y_MAX)
        else:
            for c in self.curves:
                vb = c.getViewBox()
                # vb.setXRange(0, MAX_POINTS) # <<< 수정: X축 범위 수동 설정 삭제
                vb.setYRange(Y_MIN, Y_MAX)
        self.status.showMessage("🔄 View reset")

    def update_plot(self):
        for i in range(len(self.curves)):
            if self.channel_visible[i] and len(self.data_queues[i]) > 0:
                # <<< 수정: (시간, 값) 튜플을 x, y 데이터로 분리
                data = list(self.data_queues[i])
                x = [item[0] for item in data]
                y = [item[1] for item in data]
                self.curves[i].setData(x, y, connect="finite")
            else:
                self.curves[i].setData([], [])

    # ----- 종료 -----
    def cleanup(self):
        self.reader_stop.set()
        if self.reader_thread and self.reader_thread.is_alive():
            self.reader_thread.join(timeout=1.0)
        if self.csv_file:
            try: self.csv_file.close()
            except Exception: pass
        if self.ser:
            try: self.ser.close()
            except Exception: pass


def main():
    app = QtWidgets.QApplication(sys.argv)
    pg.setConfigOptions(antialias=True, useOpenGL=False)
    win = MainWindow(); win.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
