# -*- coding: utf-8 -*-
"""
PyQt5 + PyQtGraph ê¸°ë°˜ 4ì±„ë„ ì‹¤ì‹œê°„ í”Œë¡œí„° (ë°”ì´ë„ˆë¦¬ ìˆ˜ì‹ íŒ)
- ìˆ˜ì‹  í”„ë ˆì„(10B, little-endian): <Hhhhh> = seq(uint16), ch1..ch4(int16)
- Start: 'on\n' ì „ì†¡ + CSV ë¡œê¹… ì‹œì‘ (CSV í—¤ë”: SEQ,CH1..CH4)
- Stop : 'off\n' ì „ì†¡ + CSV ë¡œê¹… ì¢…ë£Œ
- Stim : "pulses,period,duty\n" ì „ì†¡ (ASCII ê·¸ëŒ€ë¡œ)
- í¬íŠ¸ ì„ íƒ, Merge/Split, Reset View, ë‹¨ìœ„(mV, ms) í‘œê¸°
- íŒ¨í‚· ëˆ„ë½/ê°­ ê°ì§€, ìƒíƒœë°”ì— rx pkt/s, ì´ sps, per-ch sps, 16k ë‹¬ì„±ë¥ 
"""

import sys
import os
import csv
import struct
import threading
from threading import Lock
from collections import deque
from datetime import datetime

import serial
from serial import SerialException
from serial.tools import list_ports

import pyqtgraph as pg
from PyQt5 import QtWidgets, QtCore

# ===== ì„¤ì • =====
DEFAULT_PORT = "COM3"      # ì´ˆê¸° í‘œì‹œìš©
BAUDRATE = 115200          # 16ksps ë…¸ë¦¬ë©´ 1_000_000 ì´ìƒ ê¶Œì¥ (HW/ë“œë¼ì´ë²„ ì—¬ê±´ì— ë§ì¶° ì¡°ì •)
MAX_POINTS = 500           # í™”ë©´ì— ë³´ì¼ í¬ì¸íŠ¸ ê°œìˆ˜
UPDATE_INTERVAL_MS = 100   # í”Œë¡¯ ì—…ë°ì´íŠ¸ ì£¼ê¸°
Y_MIN, Y_MAX = 0, 3000     # Yì¶• ë²”ìœ„ (mV ê°€ì •)
CHANNEL_COLORS = ['r', 'g', 'b', 'y']  # CH1~CH4 ìƒ‰ìƒ

# ë°”ì´ë„ˆë¦¬ í”„ë ˆì„ í˜•ì‹
FRAME_SIZE = 10                             # <Hhhhh>
UNPACK = struct.Struct('<Hhhhh').unpack_from
SAMPLES_PER_PACKET = 4                      # íŒ¨í‚·ë‹¹ ìƒ˜í”Œ ìˆ˜(4ì±„ë„Ã—1)
TARGET_TOTAL_SPS = 16000                    # ëª©í‘œ ì´ sps (ì´ 16 ksps)

PRINT_TO_CONSOLE = False                    # í„°ë¯¸ë„ ì¶œë ¥ ìŠ¤ìœ„ì¹˜


class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Live ADC Data (4CH) [Binary Rx] - PyQt5 + PyQtGraph")

        # ìƒíƒœ ë³€ìˆ˜
        self.data_queues = [deque([0]*MAX_POINTS, maxlen=MAX_POINTS) for _ in range(4)]
        self.channel_visible = [True, True, True, True]
        self.logging_enabled = False
        self.streaming_enabled = False
        self.csv_file = None
        self.csv_writer = None
        self.last_csv_filename = None
        self.ser = None
        self.reader_thread = None
        self.reader_stop = threading.Event()
        self.merged = False  # Merge ìƒíƒœ

        # í†µê³„/ê°ì‹œ
        self.total_packets = 0
        self.lost_packets = 0
        self.malformed_lines = 0  # (ë°”ì´ë„ˆë¦¬ì—ì„œëŠ” ì‚¬ìš© ê±°ì˜ ì•ˆí•¨)
        self.gap_count = 0
        self.last_seq = None
        self.last_time = None
        self.dt_history = deque(maxlen=200)

        # rx rate
        self.pkts_since_last = 0
        self.rate_lock = Lock()
        self.prev_stats_time = QtCore.QTime.currentTime()

        # ë²„í¼(ë°”ì´ë„ˆë¦¬ ì •ë ¬)
        self.rx_buf = bytearray()

        # ========== UI ==========
        central = QtWidgets.QWidget()
        self.setCentralWidget(central)
        vbox = QtWidgets.QVBoxLayout(central)

        # ìƒë‹¨ ì»¨íŠ¸ë¡¤
        ctrl = QtWidgets.QHBoxLayout()

        # Port ì„ íƒ
        ctrl.addWidget(QtWidgets.QLabel("Port"))
        self.port_combo = QtWidgets.QComboBox()
        self.refresh_ports()
        ctrl.addWidget(self.port_combo)

        # Stim íŒŒë¼ë¯¸í„° (ASCII ì†¡ì‹  ìœ ì§€)
        ctrl.addWidget(QtWidgets.QLabel("Pulse"))
        self.pulse_edit = QtWidgets.QLineEdit(); self.pulse_edit.setFixedWidth(70); ctrl.addWidget(self.pulse_edit)
        ctrl.addWidget(QtWidgets.QLabel("Period"))
        self.period_edit = QtWidgets.QLineEdit(); self.period_edit.setFixedWidth(70); ctrl.addWidget(self.period_edit)
        ctrl.addWidget(QtWidgets.QLabel("Duty"))
        self.duty_edit = QtWidgets.QLineEdit(); self.duty_edit.setFixedWidth(70); ctrl.addWidget(self.duty_edit)
        self.btn_stim = QtWidgets.QPushButton("Stim"); self.btn_stim.clicked.connect(self.send_stimulus); ctrl.addWidget(self.btn_stim)

        ctrl.addStretch()

        # Start/Stop
        self.btn_start = QtWidgets.QPushButton("Start"); self.btn_start.clicked.connect(self.start_logging); ctrl.addWidget(self.btn_start)
        self.btn_stop  = QtWidgets.QPushButton("Stop");  self.btn_stop.clicked.connect(self.stop_logging);  ctrl.addWidget(self.btn_stop)

        # Merge/Split + Reset
        self.btn_merge_split = QtWidgets.QPushButton("Merge"); self.btn_merge_split.clicked.connect(self.toggle_merge_split); ctrl.addWidget(self.btn_merge_split)
        self.btn_reset = QtWidgets.QPushButton("Reset View"); self.btn_reset.clicked.connect(self.reset_view); ctrl.addWidget(self.btn_reset)

        # ì±„ë„ í† ê¸€
        self.cb_ch = []
        for i in range(4):
            cb = QtWidgets.QCheckBox(f"CH{i+1}")
            cb.setChecked(True)
            cb.stateChanged.connect(lambda state, idx=i: self.toggle_channel(idx, state))
            self.cb_ch.append(cb); ctrl.addWidget(cb)

        # Open CSV
        self.btn_open = QtWidgets.QPushButton("Open CSV"); self.btn_open.clicked.connect(self.open_csv); ctrl.addWidget(self.btn_open)

        vbox.addLayout(ctrl)

        # ê·¸ë˜í”„
        self.graphics = pg.GraphicsLayoutWidget(); vbox.addWidget(self.graphics)
        self.create_split_plots()

        # ìƒíƒœë°”
        self.status = self.statusBar(); self.status.showMessage("Ready")

        # íƒ€ì´ë¨¸ë“¤
        self.timer = QtCore.QTimer(self); self.timer.timeout.connect(self.update_plot); self.timer.start(UPDATE_INTERVAL_MS)
        self.stats_timer = QtCore.QTimer(self); self.stats_timer.timeout.connect(self.update_statusbar_stats); self.stats_timer.start(1000)

        # ì‹œë¦¬ì–¼ & ë¦¬ë” ìŠ¤ë ˆë“œ
        self.try_open_serial()
        self.start_reader_thread()

        # ì¢…ë£Œ
        self.destroyed.connect(self.cleanup)
        self.resize(1000, 800)

    # ----- í¬íŠ¸ -----
    def refresh_ports(self):
        self.port_combo.clear()
        ports = [p.device for p in list_ports.comports()]
        if ports:
            if DEFAULT_PORT in ports:
                ports.remove(DEFAULT_PORT); ports.insert(0, DEFAULT_PORT)
            self.port_combo.addItems(ports)
        else:
            self.port_combo.addItem("No Ports")

    def try_open_serial(self):
        port_name = self.port_combo.currentText() if self.port_combo.count() > 0 else None
        if not port_name or port_name == "No Ports":
            self.status.showMessage("No serial ports available"); return
        if self.ser:
            try: self.ser.close()
            except Exception: pass
            self.ser = None
        try:
            self.ser = serial.Serial(port_name, BAUDRATE, timeout=0.02)  # ì§§ì€ íƒ€ì„ì•„ì›ƒë¡œ ë£¨í”„ íšŒì „
            self.status.showMessage(f"Serial opened: {port_name} @ {BAUDRATE}")
        except SerialException as e:
            self.ser = None
            self.status.showMessage(f"Serial open failed: {e}")

    def start_reader_thread(self):
        self.reader_stop.clear()
        self.reader_thread = threading.Thread(target=self.reader_loop, daemon=True)
        self.reader_thread.start()

    # ----- ìˆ˜ì‹  ë£¨í”„ (ë°”ì´ë„ˆë¦¬ íŒŒì‹±) -----
    def reader_loop(self):
        while not self.reader_stop.is_set():
            if self.ser is None:
                QtCore.QThread.msleep(200); continue
            try:
                chunk = self.ser.read(4096)
                now = QtCore.QTime.currentTime()
                if not chunk:
                    # íƒ€ì„ì•„ì›ƒ â†’ gap ê°ì§€ìš© ì‹œê°„ë§Œ ê°±ì‹ 
                    if self.last_time is not None:
                        dt_ms = self.last_time.msecsTo(now)
                        if dt_ms >= 0:
                            self.dt_history.append(dt_ms)
                            if len(self.dt_history) >= 20:
                                median_dt = sorted(self.dt_history)[len(self.dt_history)//2]
                                threshold = max(10, 3 * median_dt)
                                if dt_ms > threshold:
                                    self.gap_count += 1
                                    if PRINT_TO_CONSOLE:
                                        print(f"[GAP] idle dt={dt_ms}ms (>~{threshold}ms)", flush=True)
                    self.last_time = now
                    continue

                self.rx_buf.extend(chunk)

                # 10ë°”ì´íŠ¸ì”© í”„ë ˆì„ íŒŒì‹±
                while len(self.rx_buf) >= FRAME_SIZE:
                    frame = self.rx_buf[:FRAME_SIZE]
                    del self.rx_buf[:FRAME_SIZE]

                    try:
                        seq, ch1, ch2, ch3, ch4 = UNPACK(frame)
                    except struct.error:
                        # ì´ ê²½ìš°ëŠ” ê±°ì˜ ì—†ìŒ(ê³ ì • ê¸¸ì´). í˜¹ì‹œ ì •ë ¬ ê¹¨ì§€ë©´ ë²„ë¦¬ê¸°.
                        self.malformed_lines += 1
                        continue

                    # ì½˜ì†” ì¶œë ¥(ì˜µì…˜)
                    if PRINT_TO_CONSOLE:
                        print(f"{seq},{ch1},{ch2},{ch3},{ch4}", flush=True)

                    # ê°­ ê°ì§€(íŒ¨í‚· ê°„ ì‹œê°„)
                    if self.last_time is not None:
                        dt_ms = self.last_time.msecsTo(now)
                        if dt_ms >= 0:
                            self.dt_history.append(dt_ms)
                            if len(self.dt_history) >= 20:
                                median_dt = sorted(self.dt_history)[len(self.dt_history)//2]
                                threshold = max(10, 3 * median_dt)
                                if dt_ms > threshold:
                                    self.gap_count += 1
                                    if PRINT_TO_CONSOLE:
                                        print(f"[GAP] dt={dt_ms}ms (>~{threshold}ms)", flush=True)
                    self.last_time = now

                    # ëˆ„ë½ ê°ì§€(16-bit wrap)
                    if self.last_seq is not None:
                        expected = (self.last_seq + 1) & 0xFFFF
                        missed = (seq - expected) & 0xFFFF
                        if missed != 0:
                            self.lost_packets += missed
                            if PRINT_TO_CONSOLE:
                                print(f"[LOSS] missed {missed} pkt(s): last={self.last_seq}, got={seq}", flush=True)
                    self.last_seq = seq

                    self.total_packets += 1
                    with self.rate_lock:
                        self.pkts_since_last += 1

                    # ê·¸ë˜í”„/ë¡œê¹…
                    if self.streaming_enabled:
                        vals = (ch1, ch2, ch3, ch4)
                        for i in range(4):
                            self.data_queues[i].append(vals[i])
                        if self.logging_enabled and self.csv_writer:
                            self.csv_writer.writerow([seq, ch1, ch2, ch3, ch4])

            except Exception:
                # ë…¸ì´ì¦ˆ ë“±ì€ ë¬´ì‹œ
                pass

    # ----- ìƒíƒœë°” -----
    def update_statusbar_stats(self):
        now = QtCore.QTime.currentTime()
        dt_s = max(0.001, self.prev_stats_time.msecsTo(now) / 1000.0)
        with self.rate_lock:
            delta_pkts = self.pkts_since_last
            self.pkts_since_last = 0
        rx_pkt_s = delta_pkts / dt_s

        total_sps = rx_pkt_s * SAMPLES_PER_PACKET
        per_ch_sps = total_sps / 4.0
        achieve = (total_sps / TARGET_TOTAL_SPS * 100.0) if TARGET_TOTAL_SPS > 0 else 0.0

        self.status.showMessage(
            f"pkt={self.total_packets}  loss={self.lost_packets}  malformed={self.malformed_lines}  gaps={self.gap_count}  |  "
            f"rxâ‰ˆ{rx_pkt_s:,.1f}/s  spsâ‰ˆ{total_sps:,.1f}  per-châ‰ˆ{per_ch_sps:,.1f}  |  target(16k)â‰ˆ{achieve:,.1f}%"
        )
        self.prev_stats_time = now

    # ----- ë²„íŠ¼ í•¸ë“¤ëŸ¬ -----
    def start_logging(self):
        if self.ser is None:
            self.try_open_serial()
            if self.ser is None:
                QtWidgets.QMessageBox.warning(self, "Serial", "Serial open failed.")
                return

        if not self.logging_enabled:
            filename = f"adc_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
            self.last_csv_filename = filename
            try:
                self.csv_file = open(filename, mode="w", newline="")
                self.csv_writer = csv.writer(self.csv_file)
                self.csv_writer.writerow(["SEQ", "CH1", "CH2", "CH3", "CH4"])
            except Exception as e:
                QtWidgets.QMessageBox.warning(self, "CSV", f"Failed to open CSV: {e}")
                return

            try:
                self.ser.write(b"on\n")  # ASCII ëª…ë ¹ ìœ ì§€
            except Exception:
                pass

            self.logging_enabled = True
            self.streaming_enabled = True
            self.status.showMessage(f"ğŸŸ¢ Logging started â†’ {filename}")

    def stop_logging(self):
        if self.logging_enabled:
            try:
                if self.ser:
                    self.ser.write(b"off\n")
            except Exception:
                pass

        self.logging_enabled = False
        self.streaming_enabled = False
        try:
            if self.csv_file: self.csv_file.close()
        finally:
            self.csv_file = None; self.csv_writer = None
        self.status.showMessage("ğŸ›‘ Logging stopped. CSV file closed.")

    def send_stimulus(self):
        pulses = self.pulse_edit.text().strip()
        period = self.period_edit.text().strip()
        duty = self.duty_edit.text().strip()
        if not (pulses.isdigit() and period.isdigit() and duty.isdigit()):
            QtWidgets.QMessageBox.warning(self, "Stim", "Invalid input. Use integers."); return
        cmd = f"{pulses},{period},{duty}\n".encode()
        try:
            if self.ser is None: self.try_open_serial()
            if self.ser:
                self.ser.write(cmd)
                self.status.showMessage(f"ğŸ“¤ Sent stimulus: {pulses},{period},{duty}")
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Serial", f"Write failed: {e}")

    def toggle_channel(self, idx, state):
        self.channel_visible[idx] = (state == QtCore.Qt.Checked)

    def open_csv(self):
        if self.last_csv_filename and os.path.exists(self.last_csv_filename):
            try: os.startfile(self.last_csv_filename)
            except AttributeError:
                import subprocess; opener = "open" if sys.platform == "darwin" else "xdg-open"
                subprocess.call([opener, self.last_csv_filename])
        else:
            QtWidgets.QMessageBox.information(self, "CSV", "No CSV file to open.")

    # ----- ê·¸ë˜í”„ -----
    def create_split_plots(self):
        self.graphics.clear()
        self.plots, self.curves = [], []
        for i in range(4):
            p = self.graphics.addPlot(row=i, col=0)
            p.showGrid(x=True, y=True)
            p.setLabel("left", f"CH{i+1}", units="mV")
            if i == 3: p.setLabel("bottom", "Time", units="ms")
            p.setYRange(Y_MIN, Y_MAX)
            p.setMouseEnabled(x=True, y=True)
            curve = p.plot([], [], pen=CHANNEL_COLORS[i])
            self.plots.append(p); self.curves.append(curve)

    def toggle_merge_split(self):
        self.graphics.clear()
        if not self.merged:
            p = self.graphics.addPlot(row=0, col=0)
            p.showGrid(x=True, y=True)
            p.setLabel("left", "Voltage", units="mV")
            p.setLabel("bottom", "Time", units="ms")
            p.setYRange(Y_MIN, Y_MAX)
            p.setMouseEnabled(x=True, y=True)
            self.curves = []
            for i in range(4):
                self.curves.append(p.plot([], [], pen=CHANNEL_COLORS[i], name=f"CH{i+1}"))
            self.merged = True; self.btn_merge_split.setText("Split")
        else:
            self.create_split_plots()
            self.merged = False; self.btn_merge_split.setText("Merge")

    def reset_view(self):
        if self.merged:
            if self.curves:
                vb = self.curves[0].getViewBox()
                vb.setXRange(0, MAX_POINTS); vb.setYRange(Y_MIN, Y_MAX)
        else:
            for c in self.curves:
                vb = c.getViewBox()
                vb.setXRange(0, MAX_POINTS); vb.setYRange(Y_MIN, Y_MAX)
        self.status.showMessage("ğŸ”„ View reset")

    def update_plot(self):
        for i in range(len(self.curves)):
            if self.channel_visible[i]:
                y = list(self.data_queues[i]); x = list(range(len(y)))
                self.curves[i].setData(x, y, connect="finite")
            else:
                self.curves[i].setData([], [])

    # ----- ì¢…ë£Œ -----
    def cleanup(self):
        self.reader_stop.set()
        if self.reader_thread and self.reader_thread.is_alive():
            self.reader_thread.join(timeout=1.0)
        if self.csv_file:
            try: self.csv_file.close()
            except Exception: pass
        if self.ser:
            try: self.ser.close()
            except Exception: pass


def main():
    app = QtWidgets.QApplication(sys.argv)
    pg.setConfigOptions(antialias=True, useOpenGL=False)
    win = MainWindow(); win.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
